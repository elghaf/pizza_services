{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * useVideoProcessing - Custom hook for video processing operations\n */\n\nimport { useCallback, useState } from 'react';\nimport { toast } from 'react-toastify';\nimport databaseClient from '../../../utils/DatabaseClient';\nconst useVideoProcessing = ({\n  selectedFile,\n  fps,\n  setIsProcessing,\n  setProcessingProgress,\n  setCurrentFrame,\n  setDetections,\n  setViolations,\n  onSessionUpdate,\n  wsRef\n}) => {\n  _s();\n  const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\n  // Database session management\n  const [currentSessionId, setCurrentSessionId] = useState(null);\n  const [frameCounter, setFrameCounter] = useState(0);\n  const uploadVideo = async file => {\n    const formData = new FormData();\n    formData.append('video', file);\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload`, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`Upload failed: ${response.statusText}`);\n      }\n      const result = await response.json();\n      console.log('üì§ Upload successful:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå Upload error:', error);\n      throw error;\n    }\n  };\n  const startProcessing = useCallback(async () => {\n    if (!selectedFile) {\n      toast.error('Please select a video file first');\n      return;\n    }\n    try {\n      setIsProcessing(true);\n      setProcessingProgress(0);\n      setDetections([]);\n      setViolations([]);\n      toast.info('üì§ Uploading video...');\n\n      // Upload video first\n      const uploadResult = await uploadVideo(selectedFile);\n      toast.success('‚úÖ Video uploaded successfully');\n      toast.info('üöÄ Starting video processing...');\n\n      // Start video processing\n      const processingRequest = {\n        source_type: 'file',\n        source_path: uploadResult.absolute_path,\n        fps: fps,\n        enable_violation_detection: true\n      };\n      console.log('üé¨ Starting processing with request:', processingRequest);\n      const response = await fetch(`${API_BASE_URL}/video/start`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(processingRequest)\n      });\n      if (!response.ok) {\n        const errorData = await response.text();\n        throw new Error(`Processing failed: ${errorData}`);\n      }\n      const result = await response.json();\n      console.log('‚úÖ Processing started:', result);\n\n      // Create database session\n      try {\n        const sessionData = {\n          id: result.session_id,\n          video_path: uploadResult.absolute_path,\n          video_filename: selectedFile.name,\n          fps: fps,\n          metadata: {\n            upload_result: uploadResult,\n            processing_request: processingRequest,\n            websocket_url: result.websocket_url\n          }\n        };\n        await databaseClient.createSession(sessionData);\n        setCurrentSessionId(result.session_id);\n        setFrameCounter(0);\n        console.log('üìä Database session created:', result.session_id);\n      } catch (dbError) {\n        console.error('‚ùå Failed to create database session:', dbError);\n        // Continue processing even if database fails\n      }\n      if (onSessionUpdate) {\n        onSessionUpdate(result);\n      }\n\n      // Connect to WebSocket for real-time updates\n      if (result.websocket_url && wsRef) {\n        const wsUrl = result.websocket_url.replace('localhost', window.location.hostname);\n        console.log('üîå Connecting to WebSocket:', wsUrl);\n        try {\n          const ws = new WebSocket(wsUrl);\n          wsRef.current = ws;\n          ws.onopen = () => {\n            console.log('‚úÖ WebSocket connected');\n            toast.success('üîå Connected to real-time feed');\n          };\n          ws.onmessage = event => {\n            try {\n              const data = JSON.parse(event.data);\n              console.log('üì® WebSocket message:', data.type);\n              if (data.type === 'frame_update' || data.type === 'frame_processed') {\n                var _data$frame_data, _data$detections, _data$detections2;\n                console.log('üîç Frame message details:', {\n                  hasFrameData: !!data.frame_data,\n                  frameDataLength: ((_data$frame_data = data.frame_data) === null || _data$frame_data === void 0 ? void 0 : _data$frame_data.length) || 0,\n                  frameDataType: typeof data.frame_data,\n                  hasDetections: !!data.detections,\n                  detectionsCount: ((_data$detections = data.detections) === null || _data$detections === void 0 ? void 0 : _data$detections.length) || 0,\n                  allKeys: Object.keys(data),\n                  firstDetection: (_data$detections2 = data.detections) === null || _data$detections2 === void 0 ? void 0 : _data$detections2[0]\n                });\n                setDetections(data.detections || []);\n                if (data.frame_data) {\n                  setCurrentFrame(data.frame_data);\n                  console.log('‚úÖ Frame data updated - length:', data.frame_data.length);\n                } else {\n                  console.log('‚ùå No frame_data in message - keys:', Object.keys(data));\n                }\n\n                // Save frame data to database\n                if (currentSessionId && data.detections) {\n                  var _data$frame_data2;\n                  const currentFrame = frameCounter + 1;\n                  setFrameCounter(currentFrame);\n\n                  // Prepare frame analysis data\n                  const detections = data.detections || [];\n                  const frameAnalysis = {\n                    totalDetections: detections.length,\n                    handsCount: detections.filter(d => d.class_name === 'hand').length,\n                    personsCount: detections.filter(d => d.class_name === 'person').length,\n                    scoopersCount: detections.filter(d => d.class_name === 'scooper').length,\n                    pizzasCount: detections.filter(d => d.class_name === 'pizza').length,\n                    violationsCount: 0,\n                    // Will be updated by violation detector\n                    frameSizeBytes: ((_data$frame_data2 = data.frame_data) === null || _data$frame_data2 === void 0 ? void 0 : _data$frame_data2.length) || 0,\n                    metadata: {\n                      frame_type: data.type,\n                      timestamp: new Date().toISOString()\n                    }\n                  };\n\n                  // Save to database (async, don't block UI)\n                  databaseClient.saveBatchData(currentSessionId, currentFrame, {\n                    detections: detections,\n                    frameAnalysis: frameAnalysis\n                  }).catch(error => {\n                    console.error('‚ùå Failed to save frame data to database:', error);\n                  });\n                }\n              } else if (data.type === 'violation_detected') {\n                setViolations(prev => [...prev, data.violation]);\n                toast.error(`üö® Violation: ${data.violation.description}`);\n              } else if (data.type === 'processing_progress') {\n                setProcessingProgress(data.progress || 0);\n              } else if (data.type === 'processing_complete') {\n                setIsProcessing(false);\n                setProcessingProgress(100);\n                toast.success('üéâ Video processing completed!');\n              } else if (data.type === 'error') {\n                console.error('‚ùå WebSocket error:', data.error);\n                toast.error(`Error: ${data.error}`);\n                setIsProcessing(false);\n              }\n            } catch (error) {\n              console.error('‚ùå Error parsing WebSocket message:', error);\n            }\n          };\n          ws.onerror = error => {\n            console.error('‚ùå WebSocket error:', error);\n            toast.error('WebSocket connection error');\n          };\n          ws.onclose = event => {\n            console.log('üîå WebSocket closed:', event.code, event.reason);\n            if (event.code !== 1000) {\n              // Not a normal closure\n              toast.warning('WebSocket connection lost');\n            }\n          };\n        } catch (wsError) {\n          console.error('‚ùå WebSocket connection failed:', wsError);\n          toast.warning('Real-time updates unavailable');\n        }\n      }\n      toast.success('üé¨ Video processing started successfully!');\n      return result;\n    } catch (error) {\n      console.error('‚ùå Processing error:', error);\n      toast.error(`Processing failed: ${error.message}`);\n      setIsProcessing(false);\n      setProcessingProgress(0);\n      throw error;\n    }\n  }, [selectedFile, fps, setIsProcessing, setProcessingProgress, setDetections, setViolations, onSessionUpdate, wsRef, API_BASE_URL]);\n  const stopProcessing = useCallback(async () => {\n    try {\n      // Close WebSocket connection\n      if (wsRef !== null && wsRef !== void 0 && wsRef.current) {\n        wsRef.current.close(1000, 'User stopped processing');\n        wsRef.current = null;\n      }\n\n      // Update database session\n      if (currentSessionId) {\n        try {\n          await databaseClient.updateSession(currentSessionId, {\n            end_time: new Date().toISOString(),\n            status: 'completed',\n            total_frames: frameCounter\n          });\n          console.log('üìä Database session completed:', currentSessionId);\n        } catch (dbError) {\n          console.error('‚ùå Failed to update database session:', dbError);\n        }\n      }\n      console.log('‚úÖ Processing stopped successfully');\n      toast.success('‚èπÔ∏è Video processing stopped');\n\n      // Reset session state\n      setCurrentSessionId(null);\n      setFrameCounter(0);\n\n      // Note: Backend doesn't seem to have a stop endpoint yet\n      // For now, just close the WebSocket and clean up the UI\n    } catch (error) {\n      console.error('‚ùå Error stopping processing:', error);\n      toast.warning('Error stopping processing, but cleaned up locally');\n    } finally {\n      setIsProcessing(false);\n      setProcessingProgress(0);\n    }\n  }, [wsRef, setIsProcessing, setProcessingProgress]);\n  const getProcessingStatus = useCallback(async sessionId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/video/status/${sessionId}`);\n      if (!response.ok) {\n        throw new Error(`Status check failed: ${response.statusText}`);\n      }\n      const status = await response.json();\n      return status;\n    } catch (error) {\n      console.error('‚ùå Error getting processing status:', error);\n      return null;\n    }\n  }, [API_BASE_URL]);\n  return {\n    startProcessing,\n    stopProcessing,\n    getProcessingStatus,\n    uploadVideo,\n    currentSessionId,\n    frameCounter\n  };\n};\n_s(useVideoProcessing, \"URWfVR4JA9Ag7weB2qAvg7NiF+8=\");\nexport default useVideoProcessing;","map":{"version":3,"names":["useCallback","useState","toast","databaseClient","useVideoProcessing","selectedFile","fps","setIsProcessing","setProcessingProgress","setCurrentFrame","setDetections","setViolations","onSessionUpdate","wsRef","_s","API_BASE_URL","process","env","REACT_APP_API_URL","currentSessionId","setCurrentSessionId","frameCounter","setFrameCounter","uploadVideo","file","formData","FormData","append","response","fetch","method","body","ok","Error","statusText","result","json","console","log","error","startProcessing","info","uploadResult","success","processingRequest","source_type","source_path","absolute_path","enable_violation_detection","headers","JSON","stringify","errorData","text","sessionData","id","session_id","video_path","video_filename","name","metadata","upload_result","processing_request","websocket_url","createSession","dbError","wsUrl","replace","window","location","hostname","ws","WebSocket","current","onopen","onmessage","event","data","parse","type","_data$frame_data","_data$detections","_data$detections2","hasFrameData","frame_data","frameDataLength","length","frameDataType","hasDetections","detections","detectionsCount","allKeys","Object","keys","firstDetection","_data$frame_data2","currentFrame","frameAnalysis","totalDetections","handsCount","filter","d","class_name","personsCount","scoopersCount","pizzasCount","violationsCount","frameSizeBytes","frame_type","timestamp","Date","toISOString","saveBatchData","catch","prev","violation","description","progress","onerror","onclose","code","reason","warning","wsError","message","stopProcessing","close","updateSession","end_time","status","total_frames","getProcessingStatus","sessionId"],"sources":["C:/Users/ayoub/OneDrive/Desktop/eagleAI/pizza_store_detection/services/frontend/src/components/VideoProcessor/hooks/useVideoProcessing.js"],"sourcesContent":["/**\n * useVideoProcessing - Custom hook for video processing operations\n */\n\nimport { useCallback, useState } from 'react';\nimport { toast } from 'react-toastify';\nimport databaseClient from '../../../utils/DatabaseClient';\n\nconst useVideoProcessing = ({\n  selectedFile,\n  fps,\n  setIsProcessing,\n  setProcessingProgress,\n  setCurrentFrame,\n  setDetections,\n  setViolations,\n  onSessionUpdate,\n  wsRef\n}) => {\n  const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\n  // Database session management\n  const [currentSessionId, setCurrentSessionId] = useState(null);\n  const [frameCounter, setFrameCounter] = useState(0);\n\n  const uploadVideo = async (file) => {\n    const formData = new FormData();\n    formData.append('video', file);\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload`, {\n        method: 'POST',\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Upload failed: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      console.log('üì§ Upload successful:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå Upload error:', error);\n      throw error;\n    }\n  };\n\n  const startProcessing = useCallback(async () => {\n    if (!selectedFile) {\n      toast.error('Please select a video file first');\n      return;\n    }\n\n    try {\n      setIsProcessing(true);\n      setProcessingProgress(0);\n      setDetections([]);\n      setViolations([]);\n\n      toast.info('üì§ Uploading video...');\n\n      // Upload video first\n      const uploadResult = await uploadVideo(selectedFile);\n      \n      toast.success('‚úÖ Video uploaded successfully');\n      toast.info('üöÄ Starting video processing...');\n\n      // Start video processing\n      const processingRequest = {\n        source_type: 'file',\n        source_path: uploadResult.absolute_path,\n        fps: fps,\n        enable_violation_detection: true\n      };\n\n      console.log('üé¨ Starting processing with request:', processingRequest);\n\n      const response = await fetch(`${API_BASE_URL}/video/start`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(processingRequest),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.text();\n        throw new Error(`Processing failed: ${errorData}`);\n      }\n\n      const result = await response.json();\n      console.log('‚úÖ Processing started:', result);\n\n      // Create database session\n      try {\n        const sessionData = {\n          id: result.session_id,\n          video_path: uploadResult.absolute_path,\n          video_filename: selectedFile.name,\n          fps: fps,\n          metadata: {\n            upload_result: uploadResult,\n            processing_request: processingRequest,\n            websocket_url: result.websocket_url\n          }\n        };\n\n        await databaseClient.createSession(sessionData);\n        setCurrentSessionId(result.session_id);\n        setFrameCounter(0);\n        console.log('üìä Database session created:', result.session_id);\n      } catch (dbError) {\n        console.error('‚ùå Failed to create database session:', dbError);\n        // Continue processing even if database fails\n      }\n\n      if (onSessionUpdate) {\n        onSessionUpdate(result);\n      }\n\n      // Connect to WebSocket for real-time updates\n      if (result.websocket_url && wsRef) {\n        const wsUrl = result.websocket_url.replace('localhost', window.location.hostname);\n        console.log('üîå Connecting to WebSocket:', wsUrl);\n        \n        try {\n          const ws = new WebSocket(wsUrl);\n          wsRef.current = ws;\n\n          ws.onopen = () => {\n            console.log('‚úÖ WebSocket connected');\n            toast.success('üîå Connected to real-time feed');\n          };\n\n          ws.onmessage = (event) => {\n            try {\n              const data = JSON.parse(event.data);\n              console.log('üì® WebSocket message:', data.type);\n\n              if (data.type === 'frame_update' || data.type === 'frame_processed') {\n                console.log('üîç Frame message details:', {\n                  hasFrameData: !!data.frame_data,\n                  frameDataLength: data.frame_data?.length || 0,\n                  frameDataType: typeof data.frame_data,\n                  hasDetections: !!data.detections,\n                  detectionsCount: data.detections?.length || 0,\n                  allKeys: Object.keys(data),\n                  firstDetection: data.detections?.[0]\n                });\n\n                setDetections(data.detections || []);\n\n                if (data.frame_data) {\n                  setCurrentFrame(data.frame_data);\n                  console.log('‚úÖ Frame data updated - length:', data.frame_data.length);\n                } else {\n                  console.log('‚ùå No frame_data in message - keys:', Object.keys(data));\n                }\n\n                // Save frame data to database\n                if (currentSessionId && data.detections) {\n                  const currentFrame = frameCounter + 1;\n                  setFrameCounter(currentFrame);\n\n                  // Prepare frame analysis data\n                  const detections = data.detections || [];\n                  const frameAnalysis = {\n                    totalDetections: detections.length,\n                    handsCount: detections.filter(d => d.class_name === 'hand').length,\n                    personsCount: detections.filter(d => d.class_name === 'person').length,\n                    scoopersCount: detections.filter(d => d.class_name === 'scooper').length,\n                    pizzasCount: detections.filter(d => d.class_name === 'pizza').length,\n                    violationsCount: 0, // Will be updated by violation detector\n                    frameSizeBytes: data.frame_data?.length || 0,\n                    metadata: {\n                      frame_type: data.type,\n                      timestamp: new Date().toISOString()\n                    }\n                  };\n\n                  // Save to database (async, don't block UI)\n                  databaseClient.saveBatchData(currentSessionId, currentFrame, {\n                    detections: detections,\n                    frameAnalysis: frameAnalysis\n                  }).catch(error => {\n                    console.error('‚ùå Failed to save frame data to database:', error);\n                  });\n                }\n              } else if (data.type === 'violation_detected') {\n                setViolations(prev => [...prev, data.violation]);\n                toast.error(`üö® Violation: ${data.violation.description}`);\n              } else if (data.type === 'processing_progress') {\n                setProcessingProgress(data.progress || 0);\n              } else if (data.type === 'processing_complete') {\n                setIsProcessing(false);\n                setProcessingProgress(100);\n                toast.success('üéâ Video processing completed!');\n              } else if (data.type === 'error') {\n                console.error('‚ùå WebSocket error:', data.error);\n                toast.error(`Error: ${data.error}`);\n                setIsProcessing(false);\n              }\n            } catch (error) {\n              console.error('‚ùå Error parsing WebSocket message:', error);\n            }\n          };\n\n          ws.onerror = (error) => {\n            console.error('‚ùå WebSocket error:', error);\n            toast.error('WebSocket connection error');\n          };\n\n          ws.onclose = (event) => {\n            console.log('üîå WebSocket closed:', event.code, event.reason);\n            if (event.code !== 1000) { // Not a normal closure\n              toast.warning('WebSocket connection lost');\n            }\n          };\n\n        } catch (wsError) {\n          console.error('‚ùå WebSocket connection failed:', wsError);\n          toast.warning('Real-time updates unavailable');\n        }\n      }\n\n      toast.success('üé¨ Video processing started successfully!');\n      return result;\n\n    } catch (error) {\n      console.error('‚ùå Processing error:', error);\n      toast.error(`Processing failed: ${error.message}`);\n      setIsProcessing(false);\n      setProcessingProgress(0);\n      throw error;\n    }\n  }, [selectedFile, fps, setIsProcessing, setProcessingProgress, setDetections, setViolations, onSessionUpdate, wsRef, API_BASE_URL]);\n\n  const stopProcessing = useCallback(async () => {\n    try {\n      // Close WebSocket connection\n      if (wsRef?.current) {\n        wsRef.current.close(1000, 'User stopped processing');\n        wsRef.current = null;\n      }\n\n      // Update database session\n      if (currentSessionId) {\n        try {\n          await databaseClient.updateSession(currentSessionId, {\n            end_time: new Date().toISOString(),\n            status: 'completed',\n            total_frames: frameCounter\n          });\n          console.log('üìä Database session completed:', currentSessionId);\n        } catch (dbError) {\n          console.error('‚ùå Failed to update database session:', dbError);\n        }\n      }\n\n      console.log('‚úÖ Processing stopped successfully');\n      toast.success('‚èπÔ∏è Video processing stopped');\n\n      // Reset session state\n      setCurrentSessionId(null);\n      setFrameCounter(0);\n\n      // Note: Backend doesn't seem to have a stop endpoint yet\n      // For now, just close the WebSocket and clean up the UI\n\n    } catch (error) {\n      console.error('‚ùå Error stopping processing:', error);\n      toast.warning('Error stopping processing, but cleaned up locally');\n    } finally {\n      setIsProcessing(false);\n      setProcessingProgress(0);\n    }\n  }, [wsRef, setIsProcessing, setProcessingProgress]);\n\n  const getProcessingStatus = useCallback(async (sessionId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/video/status/${sessionId}`);\n      \n      if (!response.ok) {\n        throw new Error(`Status check failed: ${response.statusText}`);\n      }\n\n      const status = await response.json();\n      return status;\n    } catch (error) {\n      console.error('‚ùå Error getting processing status:', error);\n      return null;\n    }\n  }, [API_BASE_URL]);\n\n  return {\n    startProcessing,\n    stopProcessing,\n    getProcessingStatus,\n    uploadVideo,\n    currentSessionId,\n    frameCounter\n  };\n};\n\nexport default useVideoProcessing;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}