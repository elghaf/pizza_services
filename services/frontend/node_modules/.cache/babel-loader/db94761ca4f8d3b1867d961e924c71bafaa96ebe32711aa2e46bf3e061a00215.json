{"ast":null,"code":"/**\n * Violation Analysis Utilities\n * Core logic for detecting and analyzing food safety violations\n */\n\nimport { createViolation } from '../ViolationTypes';\n\n/**\n * Analyze detections for potential violations\n * @param {Array} detections - Current frame detections\n * @param {Array} zones - ROI zones configuration\n * @param {object} settings - Detection settings\n * @param {Map} handTrackingRef - Hand tracking reference\n * @returns {Array} Array of detected violations\n */\nexport const analyzeViolations = (detections, zones, settings, handTrackingRef) => {\n  const currentTime = Date.now();\n  const newViolations = [];\n\n  // Get current hands and scoopers\n  const hands = detections.filter(d => d.class_name === 'hand');\n  const scoopers = detections.filter(d => d.class_name === 'scooper');\n  const persons = detections.filter(d => d.class_name === 'person');\n  console.log('ðŸ” Analyzing violations:', {\n    hands: hands.length,\n    scoopers: scoopers.length,\n    persons: persons.length,\n    zones: zones.length\n  });\n\n  // Analyze each hand\n  hands.forEach((hand, handIndex) => {\n    const handId = `hand_${handIndex}`;\n    const handCenter = {\n      x: (hand.bbox.x1 + hand.bbox.x2) / 2,\n      y: (hand.bbox.y1 + hand.bbox.y2) / 2\n    };\n\n    // Update hand tracking\n    updateHandTracking(handId, handCenter, hand.confidence, currentTime, settings, handTrackingRef);\n    const handTracking = handTrackingRef.current.get(handId);\n\n    // Check which zone the hand is in\n    const currentZone = findZoneContainingPoint(handCenter.x, handCenter.y, zones);\n    if (currentZone && currentZone.requiresScooper) {\n      // Check for scooper presence near this hand\n      const nearbyScoopers = findNearbyScoopers(handCenter, scoopers);\n\n      // Check for movement (indicates handling, not just cleaning)\n      const isHandling = checkHandMovement(handTracking.positions, settings);\n\n      // VIOLATION: Hand in ingredient area without scooper\n      if (nearbyScoopers.length === 0 && isHandling) {\n        const violation = createViolation('HAND_IN_INGREDIENT_NO_SCOOPER', {\n          handId,\n          hand,\n          zone: currentZone,\n          confidence: hand.confidence,\n          position: handCenter,\n          duration: (currentTime - handTracking.firstDetected) / 1000\n        });\n        newViolations.push(violation);\n      }\n\n      // VIOLATION: Cross contamination check\n      if (handTracking.lastZone && handTracking.lastZone.id !== currentZone.id && handTracking.lastZone.requiresScooper) {\n        const violation = createViolation('CROSS_CONTAMINATION', {\n          handId,\n          hand,\n          fromZone: handTracking.lastZone,\n          toZone: currentZone,\n          confidence: hand.confidence * 0.8,\n          // Slightly lower confidence\n          position: handCenter\n        });\n        newViolations.push(violation);\n      }\n\n      // VIOLATION: Extended contact\n      const contactDuration = (currentTime - handTracking.firstDetected) / 1000;\n      if (contactDuration > 5 && nearbyScoopers.length === 0) {\n        // 5 seconds\n        const violation = createViolation('EXTENDED_CONTACT', {\n          handId,\n          hand,\n          zone: currentZone,\n          confidence: Math.min(hand.confidence + 0.1, 1.0),\n          position: handCenter,\n          duration: contactDuration\n        });\n        newViolations.push(violation);\n      }\n      handTracking.lastZone = currentZone;\n    }\n  });\n\n  // Clean up old hand tracking data\n  cleanupHandTracking(hands, currentTime, handTrackingRef);\n  return newViolations;\n};\n\n/**\n * Update hand tracking information\n * @param {string} handId - Unique hand identifier\n * @param {object} handCenter - Hand center coordinates\n * @param {number} confidence - Detection confidence\n * @param {number} currentTime - Current timestamp\n * @param {object} settings - Detection settings\n * @param {Map} handTrackingRef - Hand tracking reference\n */\nexport const updateHandTracking = (handId, handCenter, confidence, currentTime, settings, handTrackingRef) => {\n  if (!handTrackingRef.current.has(handId)) {\n    handTrackingRef.current.set(handId, {\n      positions: [],\n      lastZone: null,\n      firstDetected: currentTime\n    });\n  }\n  const handTracking = handTrackingRef.current.get(handId);\n  handTracking.positions.push({\n    ...handCenter,\n    timestamp: currentTime,\n    confidence: confidence\n  });\n\n  // Keep only recent positions (temporal window)\n  const windowMs = settings.temporalWindow * 1000;\n  handTracking.positions = handTracking.positions.filter(pos => currentTime - pos.timestamp < windowMs);\n};\n\n/**\n * Find nearby scoopers within detection range\n * @param {object} handCenter - Hand center coordinates\n * @param {Array} scoopers - Array of scooper detections\n * @param {number} maxDistance - Maximum distance in pixels (default: 100)\n * @returns {Array} Array of nearby scoopers\n */\nexport const findNearbyScoopers = (handCenter, scoopers, maxDistance = 100) => {\n  return scoopers.filter(scooper => {\n    const scooperCenter = {\n      x: (scooper.bbox.x1 + scooper.bbox.x2) / 2,\n      y: (scooper.bbox.y1 + scooper.bbox.y2) / 2\n    };\n    const distance = Math.sqrt(Math.pow(handCenter.x - scooperCenter.x, 2) + Math.pow(handCenter.y - scooperCenter.y, 2));\n    return distance < maxDistance;\n  });\n};\n\n/**\n * Check if hand is showing handling movement patterns\n * @param {Array} positions - Array of hand positions over time\n * @param {object} settings - Detection settings\n * @returns {boolean} True if hand is handling ingredients\n */\nexport const checkHandMovement = (positions, settings) => {\n  if (positions.length < 2) return false;\n  let totalMovement = 0;\n  for (let i = 1; i < positions.length; i++) {\n    const distance = Math.sqrt(Math.pow(positions[i].x - positions[i - 1].x, 2) + Math.pow(positions[i].y - positions[i - 1].y, 2));\n    totalMovement += distance;\n  }\n  return totalMovement > settings.movementThreshold;\n};\n\n/**\n * Find zone containing a specific point\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {Array} zones - Array of ROI zones\n * @returns {object|null} Zone containing the point or null\n */\nexport const findZoneContainingPoint = (x, y, zones) => {\n  const foundZone = zones.find(zone => {\n    if (zone.shape === 'polygon' && zone.points && zone.points.length >= 3) {\n      // Handle polygon zones\n      const inZone = isPointInPolygon({\n        x,\n        y\n      }, zone.points);\n      if (inZone) {\n        console.log(`ðŸ”º Point (${x.toFixed(1)}, ${y.toFixed(1)}) is in polygon zone ${zone.name}:`, {\n          point: {\n            x,\n            y\n          },\n          polygonPoints: zone.points.length,\n          zoneName: zone.name\n        });\n      }\n      return inZone;\n    } else if (zone.points && zone.points.length === 2) {\n      // Handle rectangle zones (legacy format)\n      const [p1, p2] = zone.points;\n      const inZone = x >= Math.min(p1.x, p2.x) && x <= Math.max(p1.x, p2.x) && y >= Math.min(p1.y, p2.y) && y <= Math.max(p1.y, p2.y);\n      if (inZone) {\n        console.log(`ðŸ“¦ Point (${x.toFixed(1)}, ${y.toFixed(1)}) is in rectangle zone ${zone.name}:`, {\n          point: {\n            x,\n            y\n          },\n          zone: {\n            p1,\n            p2\n          },\n          zoneName: zone.name\n        });\n      }\n      return inZone;\n    }\n    return false;\n  });\n  return foundZone;\n};\n\n/**\n * Point-in-polygon algorithm for polygon zone detection\n * @param {object} point - Point with x, y coordinates\n * @param {Array} polygon - Array of polygon points\n * @returns {boolean} True if point is inside polygon\n */\nexport const isPointInPolygon = (point, polygon) => {\n  const x = point.x;\n  const y = point.y;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n      inside = !inside;\n    }\n  }\n  return inside;\n};\n\n/**\n * Clean up old hand tracking data\n * @param {Array} hands - Current hand detections\n * @param {number} currentTime - Current timestamp\n * @param {Map} handTrackingRef - Hand tracking reference\n */\nexport const cleanupHandTracking = (hands, currentTime, handTrackingRef) => {\n  const activeHandIds = hands.map((_, index) => `hand_${index}`);\n  for (const [handId, tracking] of handTrackingRef.current.entries()) {\n    var _tracking$positions;\n    if (!activeHandIds.includes(handId) && currentTime - ((_tracking$positions = tracking.positions[tracking.positions.length - 1]) === null || _tracking$positions === void 0 ? void 0 : _tracking$positions.timestamp) > 2000) {\n      handTrackingRef.current.delete(handId);\n    }\n  }\n};\n\n/**\n * Calculate violation statistics\n * @param {Array} violationHistory - Historical violations\n * @returns {object} Violation statistics\n */\nexport const getViolationStats = violationHistory => {\n  const now = new Date();\n  const last24h = violationHistory.filter(v => {\n    const violationTime = new Date(v.timestamp);\n    const hoursDiff = (now - violationTime) / (1000 * 60 * 60);\n    return hoursDiff < 24;\n  });\n  const byType = {};\n  last24h.forEach(v => {\n    byType[v.type] = (byType[v.type] || 0) + 1;\n  });\n  const bySeverity = {};\n  last24h.forEach(v => {\n    bySeverity[v.severity] = (bySeverity[v.severity] || 0) + 1;\n  });\n  return {\n    total: violationHistory.length,\n    last24h: last24h.length,\n    byType,\n    bySeverity,\n    averageConfidence: last24h.length > 0 ? last24h.reduce((sum, v) => sum + v.confidence, 0) / last24h.length : 0\n  };\n};\n\n/**\n * Filter violations by criteria\n * @param {Array} violations - Array of violations\n * @param {object} criteria - Filter criteria\n * @returns {Array} Filtered violations\n */\nexport const filterViolations = (violations, criteria = {}) => {\n  let filtered = [...violations];\n  if (criteria.severity) {\n    filtered = filtered.filter(v => v.severity === criteria.severity);\n  }\n  if (criteria.type) {\n    filtered = filtered.filter(v => v.type === criteria.type);\n  }\n  if (criteria.minConfidence) {\n    filtered = filtered.filter(v => v.confidence >= criteria.minConfidence);\n  }\n  if (criteria.timeRange) {\n    const now = Date.now();\n    const timeLimit = now - criteria.timeRange * 1000;\n    filtered = filtered.filter(v => new Date(v.timestamp).getTime() >= timeLimit);\n  }\n  if (criteria.resolved !== undefined) {\n    filtered = filtered.filter(v => v.resolved === criteria.resolved);\n  }\n  return filtered;\n};","map":{"version":3,"names":["createViolation","analyzeViolations","detections","zones","settings","handTrackingRef","currentTime","Date","now","newViolations","hands","filter","d","class_name","scoopers","persons","console","log","length","forEach","hand","handIndex","handId","handCenter","x","bbox","x1","x2","y","y1","y2","updateHandTracking","confidence","handTracking","current","get","currentZone","findZoneContainingPoint","requiresScooper","nearbyScoopers","findNearbyScoopers","isHandling","checkHandMovement","positions","violation","zone","position","duration","firstDetected","push","lastZone","id","fromZone","toZone","contactDuration","Math","min","cleanupHandTracking","has","set","timestamp","windowMs","temporalWindow","pos","maxDistance","scooper","scooperCenter","distance","sqrt","pow","totalMovement","i","movementThreshold","foundZone","find","shape","points","inZone","isPointInPolygon","toFixed","name","point","polygonPoints","zoneName","p1","p2","max","polygon","inside","j","xi","yi","xj","yj","activeHandIds","map","_","index","tracking","entries","_tracking$positions","includes","delete","getViolationStats","violationHistory","last24h","v","violationTime","hoursDiff","byType","type","bySeverity","severity","total","averageConfidence","reduce","sum","filterViolations","violations","criteria","filtered","minConfidence","timeRange","timeLimit","getTime","resolved","undefined"],"sources":["C:/Users/ayoub/OneDrive/Desktop/eagleAI/pizza_store_detection/services/frontend/src/components/ViolationDetector/utils/ViolationAnalysis.js"],"sourcesContent":["/**\n * Violation Analysis Utilities\n * Core logic for detecting and analyzing food safety violations\n */\n\nimport { createViolation } from '../ViolationTypes';\n\n/**\n * Analyze detections for potential violations\n * @param {Array} detections - Current frame detections\n * @param {Array} zones - ROI zones configuration\n * @param {object} settings - Detection settings\n * @param {Map} handTrackingRef - Hand tracking reference\n * @returns {Array} Array of detected violations\n */\nexport const analyzeViolations = (detections, zones, settings, handTrackingRef) => {\n  const currentTime = Date.now();\n  const newViolations = [];\n\n  // Get current hands and scoopers\n  const hands = detections.filter(d => d.class_name === 'hand');\n  const scoopers = detections.filter(d => d.class_name === 'scooper');\n  const persons = detections.filter(d => d.class_name === 'person');\n\n  console.log('ðŸ” Analyzing violations:', {\n    hands: hands.length,\n    scoopers: scoopers.length,\n    persons: persons.length,\n    zones: zones.length\n  });\n\n  // Analyze each hand\n  hands.forEach((hand, handIndex) => {\n    const handId = `hand_${handIndex}`;\n    const handCenter = {\n      x: (hand.bbox.x1 + hand.bbox.x2) / 2,\n      y: (hand.bbox.y1 + hand.bbox.y2) / 2\n    };\n\n    // Update hand tracking\n    updateHandTracking(handId, handCenter, hand.confidence, currentTime, settings, handTrackingRef);\n\n    const handTracking = handTrackingRef.current.get(handId);\n\n    // Check which zone the hand is in\n    const currentZone = findZoneContainingPoint(handCenter.x, handCenter.y, zones);\n    \n    if (currentZone && currentZone.requiresScooper) {\n      // Check for scooper presence near this hand\n      const nearbyScoopers = findNearbyScoopers(handCenter, scoopers);\n\n      // Check for movement (indicates handling, not just cleaning)\n      const isHandling = checkHandMovement(handTracking.positions, settings);\n\n      // VIOLATION: Hand in ingredient area without scooper\n      if (nearbyScoopers.length === 0 && isHandling) {\n        const violation = createViolation(\n          'HAND_IN_INGREDIENT_NO_SCOOPER',\n          {\n            handId,\n            hand,\n            zone: currentZone,\n            confidence: hand.confidence,\n            position: handCenter,\n            duration: (currentTime - handTracking.firstDetected) / 1000\n          }\n        );\n        newViolations.push(violation);\n      }\n\n      // VIOLATION: Cross contamination check\n      if (handTracking.lastZone && \n          handTracking.lastZone.id !== currentZone.id && \n          handTracking.lastZone.requiresScooper) {\n        const violation = createViolation(\n          'CROSS_CONTAMINATION',\n          {\n            handId,\n            hand,\n            fromZone: handTracking.lastZone,\n            toZone: currentZone,\n            confidence: hand.confidence * 0.8, // Slightly lower confidence\n            position: handCenter\n          }\n        );\n        newViolations.push(violation);\n      }\n\n      // VIOLATION: Extended contact\n      const contactDuration = (currentTime - handTracking.firstDetected) / 1000;\n      if (contactDuration > 5 && nearbyScoopers.length === 0) { // 5 seconds\n        const violation = createViolation(\n          'EXTENDED_CONTACT',\n          {\n            handId,\n            hand,\n            zone: currentZone,\n            confidence: Math.min(hand.confidence + 0.1, 1.0),\n            position: handCenter,\n            duration: contactDuration\n          }\n        );\n        newViolations.push(violation);\n      }\n\n      handTracking.lastZone = currentZone;\n    }\n  });\n\n  // Clean up old hand tracking data\n  cleanupHandTracking(hands, currentTime, handTrackingRef);\n\n  return newViolations;\n};\n\n/**\n * Update hand tracking information\n * @param {string} handId - Unique hand identifier\n * @param {object} handCenter - Hand center coordinates\n * @param {number} confidence - Detection confidence\n * @param {number} currentTime - Current timestamp\n * @param {object} settings - Detection settings\n * @param {Map} handTrackingRef - Hand tracking reference\n */\nexport const updateHandTracking = (handId, handCenter, confidence, currentTime, settings, handTrackingRef) => {\n  if (!handTrackingRef.current.has(handId)) {\n    handTrackingRef.current.set(handId, {\n      positions: [],\n      lastZone: null,\n      firstDetected: currentTime\n    });\n  }\n\n  const handTracking = handTrackingRef.current.get(handId);\n  handTracking.positions.push({\n    ...handCenter,\n    timestamp: currentTime,\n    confidence: confidence\n  });\n\n  // Keep only recent positions (temporal window)\n  const windowMs = settings.temporalWindow * 1000;\n  handTracking.positions = handTracking.positions.filter(\n    pos => currentTime - pos.timestamp < windowMs\n  );\n};\n\n/**\n * Find nearby scoopers within detection range\n * @param {object} handCenter - Hand center coordinates\n * @param {Array} scoopers - Array of scooper detections\n * @param {number} maxDistance - Maximum distance in pixels (default: 100)\n * @returns {Array} Array of nearby scoopers\n */\nexport const findNearbyScoopers = (handCenter, scoopers, maxDistance = 100) => {\n  return scoopers.filter(scooper => {\n    const scooperCenter = {\n      x: (scooper.bbox.x1 + scooper.bbox.x2) / 2,\n      y: (scooper.bbox.y1 + scooper.bbox.y2) / 2\n    };\n    const distance = Math.sqrt(\n      Math.pow(handCenter.x - scooperCenter.x, 2) + \n      Math.pow(handCenter.y - scooperCenter.y, 2)\n    );\n    return distance < maxDistance;\n  });\n};\n\n/**\n * Check if hand is showing handling movement patterns\n * @param {Array} positions - Array of hand positions over time\n * @param {object} settings - Detection settings\n * @returns {boolean} True if hand is handling ingredients\n */\nexport const checkHandMovement = (positions, settings) => {\n  if (positions.length < 2) return false;\n  \n  let totalMovement = 0;\n  for (let i = 1; i < positions.length; i++) {\n    const distance = Math.sqrt(\n      Math.pow(positions[i].x - positions[i-1].x, 2) + \n      Math.pow(positions[i].y - positions[i-1].y, 2)\n    );\n    totalMovement += distance;\n  }\n  \n  return totalMovement > settings.movementThreshold;\n};\n\n/**\n * Find zone containing a specific point\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {Array} zones - Array of ROI zones\n * @returns {object|null} Zone containing the point or null\n */\nexport const findZoneContainingPoint = (x, y, zones) => {\n  const foundZone = zones.find(zone => {\n    if (zone.shape === 'polygon' && zone.points && zone.points.length >= 3) {\n      // Handle polygon zones\n      const inZone = isPointInPolygon({ x, y }, zone.points);\n\n      if (inZone) {\n        console.log(`ðŸ”º Point (${x.toFixed(1)}, ${y.toFixed(1)}) is in polygon zone ${zone.name}:`, {\n          point: { x, y },\n          polygonPoints: zone.points.length,\n          zoneName: zone.name\n        });\n      }\n\n      return inZone;\n    } else if (zone.points && zone.points.length === 2) {\n      // Handle rectangle zones (legacy format)\n      const [p1, p2] = zone.points;\n      const inZone = x >= Math.min(p1.x, p2.x) && x <= Math.max(p1.x, p2.x) &&\n                    y >= Math.min(p1.y, p2.y) && y <= Math.max(p1.y, p2.y);\n\n      if (inZone) {\n        console.log(`ðŸ“¦ Point (${x.toFixed(1)}, ${y.toFixed(1)}) is in rectangle zone ${zone.name}:`, {\n          point: { x, y },\n          zone: { p1, p2 },\n          zoneName: zone.name\n        });\n      }\n\n      return inZone;\n    }\n    return false;\n  });\n\n  return foundZone;\n};\n\n/**\n * Point-in-polygon algorithm for polygon zone detection\n * @param {object} point - Point with x, y coordinates\n * @param {Array} polygon - Array of polygon points\n * @returns {boolean} True if point is inside polygon\n */\nexport const isPointInPolygon = (point, polygon) => {\n  const x = point.x;\n  const y = point.y;\n  let inside = false;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};\n\n/**\n * Clean up old hand tracking data\n * @param {Array} hands - Current hand detections\n * @param {number} currentTime - Current timestamp\n * @param {Map} handTrackingRef - Hand tracking reference\n */\nexport const cleanupHandTracking = (hands, currentTime, handTrackingRef) => {\n  const activeHandIds = hands.map((_, index) => `hand_${index}`);\n  for (const [handId, tracking] of handTrackingRef.current.entries()) {\n    if (!activeHandIds.includes(handId) && \n        currentTime - tracking.positions[tracking.positions.length - 1]?.timestamp > 2000) {\n      handTrackingRef.current.delete(handId);\n    }\n  }\n};\n\n/**\n * Calculate violation statistics\n * @param {Array} violationHistory - Historical violations\n * @returns {object} Violation statistics\n */\nexport const getViolationStats = (violationHistory) => {\n  const now = new Date();\n  const last24h = violationHistory.filter(v => {\n    const violationTime = new Date(v.timestamp);\n    const hoursDiff = (now - violationTime) / (1000 * 60 * 60);\n    return hoursDiff < 24;\n  });\n  \n  const byType = {};\n  last24h.forEach(v => {\n    byType[v.type] = (byType[v.type] || 0) + 1;\n  });\n\n  const bySeverity = {};\n  last24h.forEach(v => {\n    bySeverity[v.severity] = (bySeverity[v.severity] || 0) + 1;\n  });\n\n  return {\n    total: violationHistory.length,\n    last24h: last24h.length,\n    byType,\n    bySeverity,\n    averageConfidence: last24h.length > 0 \n      ? last24h.reduce((sum, v) => sum + v.confidence, 0) / last24h.length \n      : 0\n  };\n};\n\n/**\n * Filter violations by criteria\n * @param {Array} violations - Array of violations\n * @param {object} criteria - Filter criteria\n * @returns {Array} Filtered violations\n */\nexport const filterViolations = (violations, criteria = {}) => {\n  let filtered = [...violations];\n\n  if (criteria.severity) {\n    filtered = filtered.filter(v => v.severity === criteria.severity);\n  }\n\n  if (criteria.type) {\n    filtered = filtered.filter(v => v.type === criteria.type);\n  }\n\n  if (criteria.minConfidence) {\n    filtered = filtered.filter(v => v.confidence >= criteria.minConfidence);\n  }\n\n  if (criteria.timeRange) {\n    const now = Date.now();\n    const timeLimit = now - (criteria.timeRange * 1000);\n    filtered = filtered.filter(v => new Date(v.timestamp).getTime() >= timeLimit);\n  }\n\n  if (criteria.resolved !== undefined) {\n    filtered = filtered.filter(v => v.resolved === criteria.resolved);\n  }\n\n  return filtered;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}