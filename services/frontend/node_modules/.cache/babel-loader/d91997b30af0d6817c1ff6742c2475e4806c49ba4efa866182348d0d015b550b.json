{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * useVideoProcessing - Custom hook for video processing operations\n */\n\nimport { useCallback, useState } from 'react';\nimport { toast } from 'react-toastify';\nimport databaseClient from '../../../utils/DatabaseClient';\nconst useVideoProcessing = ({\n  selectedFile,\n  fps,\n  setIsProcessing,\n  setProcessingProgress,\n  setCurrentFrame,\n  setDetections,\n  setViolations,\n  onSessionUpdate,\n  wsRef\n}) => {\n  _s();\n  const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\n  // Database session management\n  const [currentSessionId, setCurrentSessionId] = useState(null);\n  const [frameCounter, setFrameCounter] = useState(0);\n  const uploadVideo = async file => {\n    console.log('üì§ Starting upload for file:', {\n      name: file.name,\n      size: file.size,\n      type: file.type\n    });\n    const formData = new FormData();\n    formData.append('video', file);\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload`, {\n        method: 'POST',\n        body: formData\n      });\n      if (!response.ok) {\n        throw new Error(`Upload failed: ${response.statusText}`);\n      }\n      const result = await response.json();\n      console.log('üì§ Upload successful:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå Upload error:', error);\n      throw error;\n    }\n  };\n  const startProcessing = useCallback(async () => {\n    console.log('üöÄ startProcessing called');\n    console.log('üìÅ selectedFile:', selectedFile);\n    if (!selectedFile) {\n      console.error('‚ùå No file selected');\n      toast.error('Please select a video file first');\n      return;\n    }\n    try {\n      console.log('‚úÖ Starting processing for file:', selectedFile.name);\n      setIsProcessing(true);\n      setProcessingProgress(0);\n      setDetections([]);\n      setViolations([]);\n      toast.info('üì§ Uploading video...');\n\n      // Upload video first\n      const uploadResult = await uploadVideo(selectedFile);\n      toast.success('‚úÖ Video uploaded successfully');\n      toast.info('üöÄ Starting video processing...');\n\n      // Start video processing\n      const processingRequest = {\n        source_type: 'file',\n        source_path: uploadResult.absolute_path,\n        fps: fps,\n        enable_violation_detection: true\n      };\n      console.log('üé¨ Starting processing with request:', processingRequest);\n      const response = await fetch(`${API_BASE_URL}/video/start`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(processingRequest)\n      });\n      if (!response.ok) {\n        const errorData = await response.text();\n        console.error('‚ùå Processing request failed:', {\n          status: response.status,\n          statusText: response.statusText,\n          errorData: errorData,\n          request: processingRequest\n        });\n        throw new Error(`Processing failed: ${errorData}`);\n      }\n      const result = await response.json();\n      console.log('‚úÖ Processing started:', result);\n\n      // Create database session\n      try {\n        const sessionData = {\n          id: result.session_id,\n          video_path: uploadResult.absolute_path,\n          video_filename: selectedFile.name,\n          fps: fps,\n          metadata: {\n            upload_result: uploadResult,\n            processing_request: processingRequest,\n            websocket_url: result.websocket_url\n          }\n        };\n        await databaseClient.createSession(sessionData);\n        setCurrentSessionId(result.session_id);\n        setFrameCounter(0);\n        console.log('üìä Database session created:', result.session_id);\n      } catch (dbError) {\n        console.error('‚ùå Failed to create database session:', dbError);\n        // Continue processing even if database fails\n      }\n      if (onSessionUpdate) {\n        onSessionUpdate(result);\n      }\n\n      // Connect to WebSocket for real-time updates\n      if (result.websocket_url && wsRef) {\n        const wsUrl = result.websocket_url.replace('localhost', window.location.hostname);\n        console.log('üîå Connecting to WebSocket:', wsUrl);\n        try {\n          const ws = new WebSocket(wsUrl);\n          wsRef.current = ws;\n          ws.onopen = () => {\n            console.log('‚úÖ WebSocket connected');\n            toast.success('üîå Connected to real-time feed');\n          };\n          ws.onmessage = event => {\n            try {\n              const data = JSON.parse(event.data);\n              console.log('üì® WebSocket message:', data.type);\n              if (data.type === 'frame_update' || data.type === 'frame_processed') {\n                var _data$frame_data, _data$detections, _data$detections2;\n                console.log('üîç Frame message details:', {\n                  hasFrameData: !!data.frame_data,\n                  frameDataLength: ((_data$frame_data = data.frame_data) === null || _data$frame_data === void 0 ? void 0 : _data$frame_data.length) || 0,\n                  frameDataType: typeof data.frame_data,\n                  hasDetections: !!data.detections,\n                  detectionsCount: ((_data$detections = data.detections) === null || _data$detections === void 0 ? void 0 : _data$detections.length) || 0,\n                  allKeys: Object.keys(data),\n                  firstDetection: (_data$detections2 = data.detections) === null || _data$detections2 === void 0 ? void 0 : _data$detections2[0]\n                });\n                setDetections(data.detections || []);\n                if (data.frame_data) {\n                  setCurrentFrame(data.frame_data);\n                  console.log('‚úÖ Frame data updated - length:', data.frame_data.length);\n                } else {\n                  console.log('‚ùå No frame_data in message - keys:', Object.keys(data));\n                }\n\n                // Save frame data to database\n                if (currentSessionId && data.detections) {\n                  var _data$frame_data2;\n                  const currentFrame = frameCounter + 1;\n                  setFrameCounter(currentFrame);\n\n                  // Prepare frame analysis data\n                  const detections = data.detections || [];\n                  const frameAnalysis = {\n                    totalDetections: detections.length,\n                    handsCount: detections.filter(d => d.class_name === 'hand').length,\n                    personsCount: detections.filter(d => d.class_name === 'person').length,\n                    scoopersCount: detections.filter(d => d.class_name === 'scooper').length,\n                    pizzasCount: detections.filter(d => d.class_name === 'pizza').length,\n                    violationsCount: 0,\n                    // Will be updated by violation detector\n                    frameSizeBytes: ((_data$frame_data2 = data.frame_data) === null || _data$frame_data2 === void 0 ? void 0 : _data$frame_data2.length) || 0,\n                    metadata: {\n                      frame_type: data.type,\n                      timestamp: new Date().toISOString()\n                    }\n                  };\n\n                  // Save to database (async, don't block UI)\n                  databaseClient.saveBatchData(currentSessionId, currentFrame, {\n                    detections: detections,\n                    frameAnalysis: frameAnalysis\n                  }).catch(error => {\n                    console.error('‚ùå Failed to save frame data to database:', error);\n                  });\n                }\n              } else if (data.type === 'violation_detected') {\n                setViolations(prev => [...prev, data.violation]);\n                toast.error(`üö® Violation: ${data.violation.description}`);\n              } else if (data.type === 'processing_progress') {\n                setProcessingProgress(data.progress || 0);\n              } else if (data.type === 'processing_complete') {\n                setIsProcessing(false);\n                setProcessingProgress(100);\n                toast.success('üéâ Video processing completed!');\n              } else if (data.type === 'error') {\n                console.error('‚ùå WebSocket error:', data.error);\n                toast.error(`Error: ${data.error}`);\n                setIsProcessing(false);\n              }\n            } catch (error) {\n              console.error('‚ùå Error parsing WebSocket message:', error);\n            }\n          };\n          ws.onerror = error => {\n            console.error('‚ùå WebSocket error:', error);\n            toast.error('WebSocket connection error');\n          };\n          ws.onclose = event => {\n            console.log('üîå WebSocket closed:', event.code, event.reason);\n            if (event.code !== 1000) {\n              // Not a normal closure\n              toast.warning('WebSocket connection lost');\n            }\n          };\n        } catch (wsError) {\n          console.error('‚ùå WebSocket connection failed:', wsError);\n          toast.warning('Real-time updates unavailable');\n        }\n      }\n      toast.success('üé¨ Video processing started successfully!');\n      return result;\n    } catch (error) {\n      console.error('‚ùå Processing error:', error);\n      toast.error(`Processing failed: ${error.message}`);\n      setIsProcessing(false);\n      setProcessingProgress(0);\n      throw error;\n    }\n  }, [selectedFile, fps, setIsProcessing, setProcessingProgress, setDetections, setViolations, onSessionUpdate, wsRef, API_BASE_URL]);\n  const stopProcessing = useCallback(async () => {\n    try {\n      // Close WebSocket connection\n      if (wsRef !== null && wsRef !== void 0 && wsRef.current) {\n        wsRef.current.close(1000, 'User stopped processing');\n        wsRef.current = null;\n      }\n\n      // Update database session\n      if (currentSessionId) {\n        try {\n          await databaseClient.updateSession(currentSessionId, {\n            end_time: new Date().toISOString(),\n            status: 'completed',\n            total_frames: frameCounter\n          });\n          console.log('üìä Database session completed:', currentSessionId);\n        } catch (dbError) {\n          console.error('‚ùå Failed to update database session:', dbError);\n        }\n      }\n      console.log('‚úÖ Processing stopped successfully');\n      toast.success('‚èπÔ∏è Video processing stopped');\n\n      // Reset session state\n      setCurrentSessionId(null);\n      setFrameCounter(0);\n\n      // Note: Backend doesn't seem to have a stop endpoint yet\n      // For now, just close the WebSocket and clean up the UI\n    } catch (error) {\n      console.error('‚ùå Error stopping processing:', error);\n      toast.warning('Error stopping processing, but cleaned up locally');\n    } finally {\n      setIsProcessing(false);\n      setProcessingProgress(0);\n    }\n  }, [wsRef, setIsProcessing, setProcessingProgress]);\n  const getProcessingStatus = useCallback(async sessionId => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/video/status/${sessionId}`);\n      if (!response.ok) {\n        throw new Error(`Status check failed: ${response.statusText}`);\n      }\n      const status = await response.json();\n      return status;\n    } catch (error) {\n      console.error('‚ùå Error getting processing status:', error);\n      return null;\n    }\n  }, [API_BASE_URL]);\n  return {\n    startProcessing,\n    stopProcessing,\n    getProcessingStatus,\n    uploadVideo,\n    currentSessionId,\n    frameCounter\n  };\n};\n_s(useVideoProcessing, \"URWfVR4JA9Ag7weB2qAvg7NiF+8=\");\nexport default useVideoProcessing;","map":{"version":3,"names":["useCallback","useState","toast","databaseClient","useVideoProcessing","selectedFile","fps","setIsProcessing","setProcessingProgress","setCurrentFrame","setDetections","setViolations","onSessionUpdate","wsRef","_s","API_BASE_URL","process","env","REACT_APP_API_URL","currentSessionId","setCurrentSessionId","frameCounter","setFrameCounter","uploadVideo","file","console","log","name","size","type","formData","FormData","append","response","fetch","method","body","ok","Error","statusText","result","json","error","startProcessing","info","uploadResult","success","processingRequest","source_type","source_path","absolute_path","enable_violation_detection","headers","JSON","stringify","errorData","text","status","request","sessionData","id","session_id","video_path","video_filename","metadata","upload_result","processing_request","websocket_url","createSession","dbError","wsUrl","replace","window","location","hostname","ws","WebSocket","current","onopen","onmessage","event","data","parse","_data$frame_data","_data$detections","_data$detections2","hasFrameData","frame_data","frameDataLength","length","frameDataType","hasDetections","detections","detectionsCount","allKeys","Object","keys","firstDetection","_data$frame_data2","currentFrame","frameAnalysis","totalDetections","handsCount","filter","d","class_name","personsCount","scoopersCount","pizzasCount","violationsCount","frameSizeBytes","frame_type","timestamp","Date","toISOString","saveBatchData","catch","prev","violation","description","progress","onerror","onclose","code","reason","warning","wsError","message","stopProcessing","close","updateSession","end_time","total_frames","getProcessingStatus","sessionId"],"sources":["C:/Users/ayoub/OneDrive/Desktop/eagleAI/pizza_store_detection/services/frontend/src/components/VideoProcessor/hooks/useVideoProcessing.js"],"sourcesContent":["/**\n * useVideoProcessing - Custom hook for video processing operations\n */\n\nimport { useCallback, useState } from 'react';\nimport { toast } from 'react-toastify';\nimport databaseClient from '../../../utils/DatabaseClient';\n\nconst useVideoProcessing = ({\n  selectedFile,\n  fps,\n  setIsProcessing,\n  setProcessingProgress,\n  setCurrentFrame,\n  setDetections,\n  setViolations,\n  onSessionUpdate,\n  wsRef\n}) => {\n  const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\n  // Database session management\n  const [currentSessionId, setCurrentSessionId] = useState(null);\n  const [frameCounter, setFrameCounter] = useState(0);\n\n  const uploadVideo = async (file) => {\n    console.log('üì§ Starting upload for file:', {\n      name: file.name,\n      size: file.size,\n      type: file.type\n    });\n\n    const formData = new FormData();\n    formData.append('video', file);\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/upload`, {\n        method: 'POST',\n        body: formData,\n      });\n\n      if (!response.ok) {\n        throw new Error(`Upload failed: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      console.log('üì§ Upload successful:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå Upload error:', error);\n      throw error;\n    }\n  };\n\n  const startProcessing = useCallback(async () => {\n    console.log('üöÄ startProcessing called');\n    console.log('üìÅ selectedFile:', selectedFile);\n\n    if (!selectedFile) {\n      console.error('‚ùå No file selected');\n      toast.error('Please select a video file first');\n      return;\n    }\n\n    try {\n      console.log('‚úÖ Starting processing for file:', selectedFile.name);\n      setIsProcessing(true);\n      setProcessingProgress(0);\n      setDetections([]);\n      setViolations([]);\n\n      toast.info('üì§ Uploading video...');\n\n      // Upload video first\n      const uploadResult = await uploadVideo(selectedFile);\n      \n      toast.success('‚úÖ Video uploaded successfully');\n      toast.info('üöÄ Starting video processing...');\n\n      // Start video processing\n      const processingRequest = {\n        source_type: 'file',\n        source_path: uploadResult.absolute_path,\n        fps: fps,\n        enable_violation_detection: true\n      };\n\n      console.log('üé¨ Starting processing with request:', processingRequest);\n\n      const response = await fetch(`${API_BASE_URL}/video/start`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(processingRequest),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.text();\n        console.error('‚ùå Processing request failed:', {\n          status: response.status,\n          statusText: response.statusText,\n          errorData: errorData,\n          request: processingRequest\n        });\n        throw new Error(`Processing failed: ${errorData}`);\n      }\n\n      const result = await response.json();\n      console.log('‚úÖ Processing started:', result);\n\n      // Create database session\n      try {\n        const sessionData = {\n          id: result.session_id,\n          video_path: uploadResult.absolute_path,\n          video_filename: selectedFile.name,\n          fps: fps,\n          metadata: {\n            upload_result: uploadResult,\n            processing_request: processingRequest,\n            websocket_url: result.websocket_url\n          }\n        };\n\n        await databaseClient.createSession(sessionData);\n        setCurrentSessionId(result.session_id);\n        setFrameCounter(0);\n        console.log('üìä Database session created:', result.session_id);\n      } catch (dbError) {\n        console.error('‚ùå Failed to create database session:', dbError);\n        // Continue processing even if database fails\n      }\n\n      if (onSessionUpdate) {\n        onSessionUpdate(result);\n      }\n\n      // Connect to WebSocket for real-time updates\n      if (result.websocket_url && wsRef) {\n        const wsUrl = result.websocket_url.replace('localhost', window.location.hostname);\n        console.log('üîå Connecting to WebSocket:', wsUrl);\n        \n        try {\n          const ws = new WebSocket(wsUrl);\n          wsRef.current = ws;\n\n          ws.onopen = () => {\n            console.log('‚úÖ WebSocket connected');\n            toast.success('üîå Connected to real-time feed');\n          };\n\n          ws.onmessage = (event) => {\n            try {\n              const data = JSON.parse(event.data);\n              console.log('üì® WebSocket message:', data.type);\n\n              if (data.type === 'frame_update' || data.type === 'frame_processed') {\n                console.log('üîç Frame message details:', {\n                  hasFrameData: !!data.frame_data,\n                  frameDataLength: data.frame_data?.length || 0,\n                  frameDataType: typeof data.frame_data,\n                  hasDetections: !!data.detections,\n                  detectionsCount: data.detections?.length || 0,\n                  allKeys: Object.keys(data),\n                  firstDetection: data.detections?.[0]\n                });\n\n                setDetections(data.detections || []);\n\n                if (data.frame_data) {\n                  setCurrentFrame(data.frame_data);\n                  console.log('‚úÖ Frame data updated - length:', data.frame_data.length);\n                } else {\n                  console.log('‚ùå No frame_data in message - keys:', Object.keys(data));\n                }\n\n                // Save frame data to database\n                if (currentSessionId && data.detections) {\n                  const currentFrame = frameCounter + 1;\n                  setFrameCounter(currentFrame);\n\n                  // Prepare frame analysis data\n                  const detections = data.detections || [];\n                  const frameAnalysis = {\n                    totalDetections: detections.length,\n                    handsCount: detections.filter(d => d.class_name === 'hand').length,\n                    personsCount: detections.filter(d => d.class_name === 'person').length,\n                    scoopersCount: detections.filter(d => d.class_name === 'scooper').length,\n                    pizzasCount: detections.filter(d => d.class_name === 'pizza').length,\n                    violationsCount: 0, // Will be updated by violation detector\n                    frameSizeBytes: data.frame_data?.length || 0,\n                    metadata: {\n                      frame_type: data.type,\n                      timestamp: new Date().toISOString()\n                    }\n                  };\n\n                  // Save to database (async, don't block UI)\n                  databaseClient.saveBatchData(currentSessionId, currentFrame, {\n                    detections: detections,\n                    frameAnalysis: frameAnalysis\n                  }).catch(error => {\n                    console.error('‚ùå Failed to save frame data to database:', error);\n                  });\n                }\n              } else if (data.type === 'violation_detected') {\n                setViolations(prev => [...prev, data.violation]);\n                toast.error(`üö® Violation: ${data.violation.description}`);\n              } else if (data.type === 'processing_progress') {\n                setProcessingProgress(data.progress || 0);\n              } else if (data.type === 'processing_complete') {\n                setIsProcessing(false);\n                setProcessingProgress(100);\n                toast.success('üéâ Video processing completed!');\n              } else if (data.type === 'error') {\n                console.error('‚ùå WebSocket error:', data.error);\n                toast.error(`Error: ${data.error}`);\n                setIsProcessing(false);\n              }\n            } catch (error) {\n              console.error('‚ùå Error parsing WebSocket message:', error);\n            }\n          };\n\n          ws.onerror = (error) => {\n            console.error('‚ùå WebSocket error:', error);\n            toast.error('WebSocket connection error');\n          };\n\n          ws.onclose = (event) => {\n            console.log('üîå WebSocket closed:', event.code, event.reason);\n            if (event.code !== 1000) { // Not a normal closure\n              toast.warning('WebSocket connection lost');\n            }\n          };\n\n        } catch (wsError) {\n          console.error('‚ùå WebSocket connection failed:', wsError);\n          toast.warning('Real-time updates unavailable');\n        }\n      }\n\n      toast.success('üé¨ Video processing started successfully!');\n      return result;\n\n    } catch (error) {\n      console.error('‚ùå Processing error:', error);\n      toast.error(`Processing failed: ${error.message}`);\n      setIsProcessing(false);\n      setProcessingProgress(0);\n      throw error;\n    }\n  }, [selectedFile, fps, setIsProcessing, setProcessingProgress, setDetections, setViolations, onSessionUpdate, wsRef, API_BASE_URL]);\n\n  const stopProcessing = useCallback(async () => {\n    try {\n      // Close WebSocket connection\n      if (wsRef?.current) {\n        wsRef.current.close(1000, 'User stopped processing');\n        wsRef.current = null;\n      }\n\n      // Update database session\n      if (currentSessionId) {\n        try {\n          await databaseClient.updateSession(currentSessionId, {\n            end_time: new Date().toISOString(),\n            status: 'completed',\n            total_frames: frameCounter\n          });\n          console.log('üìä Database session completed:', currentSessionId);\n        } catch (dbError) {\n          console.error('‚ùå Failed to update database session:', dbError);\n        }\n      }\n\n      console.log('‚úÖ Processing stopped successfully');\n      toast.success('‚èπÔ∏è Video processing stopped');\n\n      // Reset session state\n      setCurrentSessionId(null);\n      setFrameCounter(0);\n\n      // Note: Backend doesn't seem to have a stop endpoint yet\n      // For now, just close the WebSocket and clean up the UI\n\n    } catch (error) {\n      console.error('‚ùå Error stopping processing:', error);\n      toast.warning('Error stopping processing, but cleaned up locally');\n    } finally {\n      setIsProcessing(false);\n      setProcessingProgress(0);\n    }\n  }, [wsRef, setIsProcessing, setProcessingProgress]);\n\n  const getProcessingStatus = useCallback(async (sessionId) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/video/status/${sessionId}`);\n      \n      if (!response.ok) {\n        throw new Error(`Status check failed: ${response.statusText}`);\n      }\n\n      const status = await response.json();\n      return status;\n    } catch (error) {\n      console.error('‚ùå Error getting processing status:', error);\n      return null;\n    }\n  }, [API_BASE_URL]);\n\n  return {\n    startProcessing,\n    stopProcessing,\n    getProcessingStatus,\n    uploadVideo,\n    currentSessionId,\n    frameCounter\n  };\n};\n\nexport default useVideoProcessing;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}