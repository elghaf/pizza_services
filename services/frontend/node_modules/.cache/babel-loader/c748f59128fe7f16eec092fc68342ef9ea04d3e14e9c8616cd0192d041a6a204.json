{"ast":null,"code":"/**\n * Pizza Store Specific Violation Analysis\n * Enhanced violation detection logic for pizza store hygiene compliance\n */\n\nimport { findZoneContainingPoint, isPointInPolygon } from './ViolationAnalysis';\n\n// Pizza store specific violation types\nexport const PIZZA_STORE_VIOLATIONS = {\n  HAND_WITHOUT_SCOOPER: {\n    type: 'HAND_WITHOUT_SCOOPER',\n    severity: 'high',\n    description: 'Hand detected in ingredient area without scooper',\n    requiresScooper: true\n  },\n  CROSS_CONTAMINATION: {\n    type: 'CROSS_CONTAMINATION',\n    severity: 'high',\n    description: 'Hand moved between different ingredient areas without cleaning',\n    requiresScooper: false\n  },\n  IMPROPER_HANDLING: {\n    type: 'IMPROPER_HANDLING',\n    severity: 'medium',\n    description: 'Improper ingredient handling detected',\n    requiresScooper: true\n  },\n  CLEANING_DETECTED: {\n    type: 'CLEANING_DETECTED',\n    severity: 'info',\n    description: 'Cleaning activity detected - not a violation',\n    requiresScooper: false\n  }\n};\n\n// Movement patterns for analysis\nexport const MOVEMENT_PATTERNS = {\n  GRABBING: 'grabbing',\n  CLEANING: 'cleaning',\n  REACHING: 'reaching',\n  UNKNOWN: 'unknown'\n};\n\n// Zone types that require scoopers\nexport const SCOOPER_REQUIRED_ZONES = ['sauce_area', 'protein_area', 'cheese_area'];\n\n/**\n * Analyze hand movement pattern to distinguish between grabbing and cleaning\n * @param {Object} handTracking - Hand tracking data\n * @param {Array} recentPositions - Recent hand positions\n * @returns {string} Movement pattern\n */\nexport const analyzeMovementPattern = (handTracking, recentPositions) => {\n  if (!recentPositions || recentPositions.length < 3) {\n    return MOVEMENT_PATTERNS.UNKNOWN;\n  }\n\n  // Calculate movement characteristics\n  const movements = [];\n  for (let i = 1; i < recentPositions.length; i++) {\n    const prev = recentPositions[i - 1];\n    const curr = recentPositions[i];\n    const distance = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2));\n    movements.push(distance);\n  }\n  const avgMovement = movements.reduce((a, b) => a + b, 0) / movements.length;\n  const maxMovement = Math.max(...movements);\n\n  // Analyze movement pattern\n  if (avgMovement > 15 && maxMovement > 30) {\n    // Large, varied movements suggest cleaning\n    return MOVEMENT_PATTERNS.CLEANING;\n  } else if (avgMovement < 10 && maxMovement < 20) {\n    // Small, precise movements suggest grabbing\n    return MOVEMENT_PATTERNS.GRABBING;\n  } else if (avgMovement > 20) {\n    // Medium movements suggest reaching\n    return MOVEMENT_PATTERNS.REACHING;\n  }\n  return MOVEMENT_PATTERNS.UNKNOWN;\n};\n\n/**\n * Find nearest scooper to a hand position\n * @param {Object} handPosition - Hand center position {x, y}\n * @param {Array} scoopers - Array of scooper detections\n * @returns {Object|null} Nearest scooper with distance\n */\nexport const findNearestScooper = (handPosition, scoopers) => {\n  if (!scoopers || scoopers.length === 0) {\n    return null;\n  }\n  let nearestScooper = null;\n  let minDistance = Infinity;\n  scoopers.forEach(scooper => {\n    const scooperCenter = scooper.center || {\n      x: (scooper.bbox.x1 + scooper.bbox.x2) / 2,\n      y: (scooper.bbox.y1 + scooper.bbox.y2) / 2\n    };\n    const distance = Math.sqrt(Math.pow(handPosition.x - scooperCenter.x, 2) + Math.pow(handPosition.y - scooperCenter.y, 2));\n    if (distance < minDistance) {\n      minDistance = distance;\n      nearestScooper = {\n        scooper,\n        distance\n      };\n    }\n  });\n  return nearestScooper;\n};\n\n/**\n * Check if scooper is being used (close enough to hand)\n * @param {Object} handPosition - Hand center position\n * @param {Array} scoopers - Array of scooper detections\n * @param {number} threshold - Distance threshold for \"using\" scooper\n * @returns {boolean} True if scooper is being used\n */\nexport const isScooperBeingUsed = (handPosition, scoopers, threshold = 50) => {\n  const nearestScooper = findNearestScooper(handPosition, scoopers);\n  return nearestScooper && nearestScooper.distance <= threshold;\n};\n\n/**\n * Track worker movements between zones for cross-contamination detection\n * @param {string} workerId - Worker identifier\n * @param {Object} currentZone - Current zone the worker is in\n * @param {Map} workerZoneHistory - Map of worker zone histories\n * @returns {boolean} True if cross-contamination detected\n */\nexport const detectCrossContamination = (workerId, currentZone, workerZoneHistory) => {\n  if (!currentZone || !workerZoneHistory.has(workerId)) {\n    return false;\n  }\n  const history = workerZoneHistory.get(workerId);\n  const lastZone = history[history.length - 1];\n\n  // Check if worker moved from one ingredient area to another without cleaning\n  if (lastZone && lastZone.zone_type !== currentZone.zone_type && SCOOPER_REQUIRED_ZONES.includes(lastZone.zone_type) && SCOOPER_REQUIRED_ZONES.includes(currentZone.zone_type)) {\n    // Check if enough time passed for cleaning (simple heuristic)\n    const timeDiff = Date.now() - lastZone.timestamp;\n    if (timeDiff < 5000) {\n      // Less than 5 seconds\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Enhanced pizza store violation analysis\n * @param {Array} detections - Current frame detections\n * @param {Array} zones - ROI zones configuration\n * @param {Object} settings - Violation detection settings\n * @param {Object} handTrackingRef - Hand tracking reference\n * @returns {Array} Array of detected violations\n */\nexport const analyzePizzaStoreViolations = (detections, zones, settings, handTrackingRef) => {\n  const violations = [];\n  const currentTime = Date.now();\n\n  // Separate detections by type\n  const hands = detections.filter(d => d.class_name === 'hand');\n  const scoopers = detections.filter(d => d.class_name === 'scooper');\n  const persons = detections.filter(d => d.class_name === 'person');\n  console.log('ðŸ• Pizza Store Violation Analysis:', {\n    hands: hands.length,\n    scoopers: scoopers.length,\n    persons: persons.length,\n    zones: zones.length\n  });\n\n  // Analyze each hand detection\n  hands.forEach((hand, handIndex) => {\n    const handId = `hand_${handIndex}`;\n    const handCenter = hand.center || {\n      x: (hand.bbox.x1 + hand.bbox.x2) / 2,\n      y: (hand.bbox.y1 + hand.bbox.y2) / 2\n    };\n\n    // Update hand tracking\n    if (!handTrackingRef.current.has(handId)) {\n      handTrackingRef.current.set(handId, {\n        positions: [],\n        zoneHistory: [],\n        lastSeen: currentTime,\n        violations: []\n      });\n    }\n    const handTracking = handTrackingRef.current.get(handId);\n    handTracking.positions.push({\n      ...handCenter,\n      timestamp: currentTime\n    });\n    handTracking.lastSeen = currentTime;\n\n    // Keep only recent positions (last 2 seconds)\n    handTracking.positions = handTracking.positions.filter(pos => currentTime - pos.timestamp < 2000);\n\n    // Find which zone the hand is in\n    const currentZone = findZoneContainingPoint(handCenter.x, handCenter.y, zones);\n    if (currentZone && currentZone.requiresScooper) {\n      console.log(`ðŸŽ¯ Hand in scooper-required zone: ${currentZone.name}`);\n\n      // Analyze movement pattern\n      const movementPattern = analyzeMovementPattern(handTracking, handTracking.positions);\n\n      // Skip violation if cleaning detected\n      if (movementPattern === MOVEMENT_PATTERNS.CLEANING) {\n        console.log('ðŸ§½ Cleaning activity detected - no violation');\n        return;\n      }\n\n      // Check for scooper usage\n      const scooperUsed = isScooperBeingUsed(handCenter, scoopers);\n      const nearestScooper = findNearestScooper(handCenter, scoopers);\n      if (!scooperUsed && movementPattern === MOVEMENT_PATTERNS.GRABBING) {\n        // Create violation for hand without scooper\n        const violation = {\n          id: `violation_${Date.now()}_${handIndex}`,\n          type: PIZZA_STORE_VIOLATIONS.HAND_WITHOUT_SCOOPER.type,\n          severity: PIZZA_STORE_VIOLATIONS.HAND_WITHOUT_SCOOPER.severity,\n          description: `Hand detected in ${currentZone.name} without scooper`,\n          confidence: hand.confidence,\n          timestamp: new Date().toISOString(),\n          handPosition: handCenter,\n          zoneId: currentZone.id,\n          zoneName: currentZone.name,\n          scooperPresent: scoopers.length > 0,\n          scooperDistance: nearestScooper ? nearestScooper.distance : null,\n          movementPattern: movementPattern,\n          boundingBoxes: [hand],\n          frameData: {\n            totalHands: hands.length,\n            totalScoopers: scoopers.length,\n            totalPersons: persons.length\n          }\n        };\n        violations.push(violation);\n        handTracking.violations.push(violation);\n        console.log('ðŸš¨ VIOLATION DETECTED:', violation.type, 'in', currentZone.name);\n      }\n\n      // Update zone history\n      handTracking.zoneHistory.push({\n        zone: currentZone,\n        timestamp: currentTime,\n        movementPattern: movementPattern\n      });\n\n      // Keep only recent zone history\n      handTracking.zoneHistory = handTracking.zoneHistory.filter(entry => currentTime - entry.timestamp < 10000 // Last 10 seconds\n      );\n    }\n  });\n\n  // Clean up old hand tracking data\n  for (const [handId, tracking] of handTrackingRef.current.entries()) {\n    if (currentTime - tracking.lastSeen > 5000) {\n      // 5 seconds\n      handTrackingRef.current.delete(handId);\n    }\n  }\n  console.log(`ðŸ• Pizza Store Analysis Complete: ${violations.length} violations detected`);\n  return violations;\n};\n\n/**\n * Get violation statistics for pizza store\n * @param {Array} violations - Array of violations\n * @returns {Object} Violation statistics\n */\nexport const getPizzaStoreViolationStats = violations => {\n  const stats = {\n    total: violations.length,\n    byType: {},\n    bySeverity: {},\n    byZone: {},\n    recentViolations: violations.filter(v => Date.now() - new Date(v.timestamp).getTime() < 60000 // Last minute\n    ).length\n  };\n  violations.forEach(violation => {\n    // By type\n    stats.byType[violation.type] = (stats.byType[violation.type] || 0) + 1;\n\n    // By severity\n    stats.bySeverity[violation.severity] = (stats.bySeverity[violation.severity] || 0) + 1;\n\n    // By zone\n    if (violation.zoneName) {\n      stats.byZone[violation.zoneName] = (stats.byZone[violation.zoneName] || 0) + 1;\n    }\n  });\n  return stats;\n};","map":{"version":3,"names":["findZoneContainingPoint","isPointInPolygon","PIZZA_STORE_VIOLATIONS","HAND_WITHOUT_SCOOPER","type","severity","description","requiresScooper","CROSS_CONTAMINATION","IMPROPER_HANDLING","CLEANING_DETECTED","MOVEMENT_PATTERNS","GRABBING","CLEANING","REACHING","UNKNOWN","SCOOPER_REQUIRED_ZONES","analyzeMovementPattern","handTracking","recentPositions","length","movements","i","prev","curr","distance","Math","sqrt","pow","x","y","push","avgMovement","reduce","a","b","maxMovement","max","findNearestScooper","handPosition","scoopers","nearestScooper","minDistance","Infinity","forEach","scooper","scooperCenter","center","bbox","x1","x2","y1","y2","isScooperBeingUsed","threshold","detectCrossContamination","workerId","currentZone","workerZoneHistory","has","history","get","lastZone","zone_type","includes","timeDiff","Date","now","timestamp","analyzePizzaStoreViolations","detections","zones","settings","handTrackingRef","violations","currentTime","hands","filter","d","class_name","persons","console","log","hand","handIndex","handId","handCenter","current","set","positions","zoneHistory","lastSeen","pos","name","movementPattern","scooperUsed","violation","id","confidence","toISOString","zoneId","zoneName","scooperPresent","scooperDistance","boundingBoxes","frameData","totalHands","totalScoopers","totalPersons","zone","entry","tracking","entries","delete","getPizzaStoreViolationStats","stats","total","byType","bySeverity","byZone","recentViolations","v","getTime"],"sources":["C:/Users/ayoub/OneDrive/Desktop/eagleAI/pizza_store_detection/services/frontend/src/components/ViolationDetector/utils/PizzaStoreViolationAnalysis.js"],"sourcesContent":["/**\n * Pizza Store Specific Violation Analysis\n * Enhanced violation detection logic for pizza store hygiene compliance\n */\n\nimport { findZoneContainingPoint, isPointInPolygon } from './ViolationAnalysis';\n\n// Pizza store specific violation types\nexport const PIZZA_STORE_VIOLATIONS = {\n  HAND_WITHOUT_SCOOPER: {\n    type: 'HAND_WITHOUT_SCOOPER',\n    severity: 'high',\n    description: 'Hand detected in ingredient area without scooper',\n    requiresScooper: true\n  },\n  CROSS_CONTAMINATION: {\n    type: 'CROSS_CONTAMINATION',\n    severity: 'high',\n    description: 'Hand moved between different ingredient areas without cleaning',\n    requiresScooper: false\n  },\n  IMPROPER_HANDLING: {\n    type: 'IMPROPER_HANDLING',\n    severity: 'medium',\n    description: 'Improper ingredient handling detected',\n    requiresScooper: true\n  },\n  CLEANING_DETECTED: {\n    type: 'CLEANING_DETECTED',\n    severity: 'info',\n    description: 'Cleaning activity detected - not a violation',\n    requiresScooper: false\n  }\n};\n\n// Movement patterns for analysis\nexport const MOVEMENT_PATTERNS = {\n  GRABBING: 'grabbing',\n  CLEANING: 'cleaning',\n  REACHING: 'reaching',\n  UNKNOWN: 'unknown'\n};\n\n// Zone types that require scoopers\nexport const SCOOPER_REQUIRED_ZONES = [\n  'sauce_area',\n  'protein_area',\n  'cheese_area'\n];\n\n/**\n * Analyze hand movement pattern to distinguish between grabbing and cleaning\n * @param {Object} handTracking - Hand tracking data\n * @param {Array} recentPositions - Recent hand positions\n * @returns {string} Movement pattern\n */\nexport const analyzeMovementPattern = (handTracking, recentPositions) => {\n  if (!recentPositions || recentPositions.length < 3) {\n    return MOVEMENT_PATTERNS.UNKNOWN;\n  }\n\n  // Calculate movement characteristics\n  const movements = [];\n  for (let i = 1; i < recentPositions.length; i++) {\n    const prev = recentPositions[i - 1];\n    const curr = recentPositions[i];\n    const distance = Math.sqrt(\n      Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)\n    );\n    movements.push(distance);\n  }\n\n  const avgMovement = movements.reduce((a, b) => a + b, 0) / movements.length;\n  const maxMovement = Math.max(...movements);\n\n  // Analyze movement pattern\n  if (avgMovement > 15 && maxMovement > 30) {\n    // Large, varied movements suggest cleaning\n    return MOVEMENT_PATTERNS.CLEANING;\n  } else if (avgMovement < 10 && maxMovement < 20) {\n    // Small, precise movements suggest grabbing\n    return MOVEMENT_PATTERNS.GRABBING;\n  } else if (avgMovement > 20) {\n    // Medium movements suggest reaching\n    return MOVEMENT_PATTERNS.REACHING;\n  }\n\n  return MOVEMENT_PATTERNS.UNKNOWN;\n};\n\n/**\n * Find nearest scooper to a hand position\n * @param {Object} handPosition - Hand center position {x, y}\n * @param {Array} scoopers - Array of scooper detections\n * @returns {Object|null} Nearest scooper with distance\n */\nexport const findNearestScooper = (handPosition, scoopers) => {\n  if (!scoopers || scoopers.length === 0) {\n    return null;\n  }\n\n  let nearestScooper = null;\n  let minDistance = Infinity;\n\n  scoopers.forEach(scooper => {\n    const scooperCenter = scooper.center || {\n      x: (scooper.bbox.x1 + scooper.bbox.x2) / 2,\n      y: (scooper.bbox.y1 + scooper.bbox.y2) / 2\n    };\n\n    const distance = Math.sqrt(\n      Math.pow(handPosition.x - scooperCenter.x, 2) +\n      Math.pow(handPosition.y - scooperCenter.y, 2)\n    );\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      nearestScooper = { scooper, distance };\n    }\n  });\n\n  return nearestScooper;\n};\n\n/**\n * Check if scooper is being used (close enough to hand)\n * @param {Object} handPosition - Hand center position\n * @param {Array} scoopers - Array of scooper detections\n * @param {number} threshold - Distance threshold for \"using\" scooper\n * @returns {boolean} True if scooper is being used\n */\nexport const isScooperBeingUsed = (handPosition, scoopers, threshold = 50) => {\n  const nearestScooper = findNearestScooper(handPosition, scoopers);\n  return nearestScooper && nearestScooper.distance <= threshold;\n};\n\n/**\n * Track worker movements between zones for cross-contamination detection\n * @param {string} workerId - Worker identifier\n * @param {Object} currentZone - Current zone the worker is in\n * @param {Map} workerZoneHistory - Map of worker zone histories\n * @returns {boolean} True if cross-contamination detected\n */\nexport const detectCrossContamination = (workerId, currentZone, workerZoneHistory) => {\n  if (!currentZone || !workerZoneHistory.has(workerId)) {\n    return false;\n  }\n\n  const history = workerZoneHistory.get(workerId);\n  const lastZone = history[history.length - 1];\n\n  // Check if worker moved from one ingredient area to another without cleaning\n  if (lastZone && \n      lastZone.zone_type !== currentZone.zone_type &&\n      SCOOPER_REQUIRED_ZONES.includes(lastZone.zone_type) &&\n      SCOOPER_REQUIRED_ZONES.includes(currentZone.zone_type)) {\n    \n    // Check if enough time passed for cleaning (simple heuristic)\n    const timeDiff = Date.now() - lastZone.timestamp;\n    if (timeDiff < 5000) { // Less than 5 seconds\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Enhanced pizza store violation analysis\n * @param {Array} detections - Current frame detections\n * @param {Array} zones - ROI zones configuration\n * @param {Object} settings - Violation detection settings\n * @param {Object} handTrackingRef - Hand tracking reference\n * @returns {Array} Array of detected violations\n */\nexport const analyzePizzaStoreViolations = (detections, zones, settings, handTrackingRef) => {\n  const violations = [];\n  const currentTime = Date.now();\n\n  // Separate detections by type\n  const hands = detections.filter(d => d.class_name === 'hand');\n  const scoopers = detections.filter(d => d.class_name === 'scooper');\n  const persons = detections.filter(d => d.class_name === 'person');\n\n  console.log('ðŸ• Pizza Store Violation Analysis:', {\n    hands: hands.length,\n    scoopers: scoopers.length,\n    persons: persons.length,\n    zones: zones.length\n  });\n\n  // Analyze each hand detection\n  hands.forEach((hand, handIndex) => {\n    const handId = `hand_${handIndex}`;\n    const handCenter = hand.center || {\n      x: (hand.bbox.x1 + hand.bbox.x2) / 2,\n      y: (hand.bbox.y1 + hand.bbox.y2) / 2\n    };\n\n    // Update hand tracking\n    if (!handTrackingRef.current.has(handId)) {\n      handTrackingRef.current.set(handId, {\n        positions: [],\n        zoneHistory: [],\n        lastSeen: currentTime,\n        violations: []\n      });\n    }\n\n    const handTracking = handTrackingRef.current.get(handId);\n    handTracking.positions.push({ ...handCenter, timestamp: currentTime });\n    handTracking.lastSeen = currentTime;\n\n    // Keep only recent positions (last 2 seconds)\n    handTracking.positions = handTracking.positions.filter(\n      pos => currentTime - pos.timestamp < 2000\n    );\n\n    // Find which zone the hand is in\n    const currentZone = findZoneContainingPoint(handCenter.x, handCenter.y, zones);\n\n    if (currentZone && currentZone.requiresScooper) {\n      console.log(`ðŸŽ¯ Hand in scooper-required zone: ${currentZone.name}`);\n\n      // Analyze movement pattern\n      const movementPattern = analyzeMovementPattern(handTracking, handTracking.positions);\n      \n      // Skip violation if cleaning detected\n      if (movementPattern === MOVEMENT_PATTERNS.CLEANING) {\n        console.log('ðŸ§½ Cleaning activity detected - no violation');\n        return;\n      }\n\n      // Check for scooper usage\n      const scooperUsed = isScooperBeingUsed(handCenter, scoopers);\n      const nearestScooper = findNearestScooper(handCenter, scoopers);\n\n      if (!scooperUsed && movementPattern === MOVEMENT_PATTERNS.GRABBING) {\n        // Create violation for hand without scooper\n        const violation = {\n          id: `violation_${Date.now()}_${handIndex}`,\n          type: PIZZA_STORE_VIOLATIONS.HAND_WITHOUT_SCOOPER.type,\n          severity: PIZZA_STORE_VIOLATIONS.HAND_WITHOUT_SCOOPER.severity,\n          description: `Hand detected in ${currentZone.name} without scooper`,\n          confidence: hand.confidence,\n          timestamp: new Date().toISOString(),\n          handPosition: handCenter,\n          zoneId: currentZone.id,\n          zoneName: currentZone.name,\n          scooperPresent: scoopers.length > 0,\n          scooperDistance: nearestScooper ? nearestScooper.distance : null,\n          movementPattern: movementPattern,\n          boundingBoxes: [hand],\n          frameData: {\n            totalHands: hands.length,\n            totalScoopers: scoopers.length,\n            totalPersons: persons.length\n          }\n        };\n\n        violations.push(violation);\n        handTracking.violations.push(violation);\n\n        console.log('ðŸš¨ VIOLATION DETECTED:', violation.type, 'in', currentZone.name);\n      }\n\n      // Update zone history\n      handTracking.zoneHistory.push({\n        zone: currentZone,\n        timestamp: currentTime,\n        movementPattern: movementPattern\n      });\n\n      // Keep only recent zone history\n      handTracking.zoneHistory = handTracking.zoneHistory.filter(\n        entry => currentTime - entry.timestamp < 10000 // Last 10 seconds\n      );\n    }\n  });\n\n  // Clean up old hand tracking data\n  for (const [handId, tracking] of handTrackingRef.current.entries()) {\n    if (currentTime - tracking.lastSeen > 5000) { // 5 seconds\n      handTrackingRef.current.delete(handId);\n    }\n  }\n\n  console.log(`ðŸ• Pizza Store Analysis Complete: ${violations.length} violations detected`);\n  return violations;\n};\n\n/**\n * Get violation statistics for pizza store\n * @param {Array} violations - Array of violations\n * @returns {Object} Violation statistics\n */\nexport const getPizzaStoreViolationStats = (violations) => {\n  const stats = {\n    total: violations.length,\n    byType: {},\n    bySeverity: {},\n    byZone: {},\n    recentViolations: violations.filter(v => \n      Date.now() - new Date(v.timestamp).getTime() < 60000 // Last minute\n    ).length\n  };\n\n  violations.forEach(violation => {\n    // By type\n    stats.byType[violation.type] = (stats.byType[violation.type] || 0) + 1;\n    \n    // By severity\n    stats.bySeverity[violation.severity] = (stats.bySeverity[violation.severity] || 0) + 1;\n    \n    // By zone\n    if (violation.zoneName) {\n      stats.byZone[violation.zoneName] = (stats.byZone[violation.zoneName] || 0) + 1;\n    }\n  });\n\n  return stats;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}