{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * useWebSocket - Custom hook for WebSocket connection management\n */\n\nimport { useCallback, useEffect } from 'react';\nimport { toast } from 'react-toastify';\nconst useWebSocket = ({\n  wsRef,\n  setCurrentFrame,\n  setDetections,\n  setViolations,\n  setIsProcessing,\n  setProcessingProgress,\n  onDetectionUpdate,\n  onViolationUpdate\n}) => {\n  _s();\n  // Handle incoming WebSocket messages\n  const handleWebSocketMessage = useCallback(event => {\n    var _data$frame_data, _data$detections, _data$status;\n    try {\n      const data = JSON.parse(event.data);\n      console.log('📨 WebSocket message received:', data.type);\n      switch (data.type) {\n        case 'frame_update':\n        case 'frame_processed':\n          console.log('🖼️ Frame message received:', {\n            type: data.type,\n            hasFrameData: !!data.frame_data,\n            frameDataLength: ((_data$frame_data = data.frame_data) === null || _data$frame_data === void 0 ? void 0 : _data$frame_data.length) || 0,\n            hasDetections: !!data.detections,\n            detectionsCount: ((_data$detections = data.detections) === null || _data$detections === void 0 ? void 0 : _data$detections.length) || 0,\n            progress: data.progress,\n            allKeys: Object.keys(data)\n          });\n\n          // Update current frame\n          if (data.frame_data) {\n            setCurrentFrame(data.frame_data);\n            console.log('✅ Frame data updated - length:', data.frame_data.length);\n          } else {\n            console.log('❌ No frame_data in message');\n          }\n\n          // Update detections\n          if (data.detections) {\n            setDetections(data.detections);\n            if (onDetectionUpdate) {\n              onDetectionUpdate(data.detections);\n            }\n          }\n\n          // Update processing progress if available\n          if (data.progress !== undefined) {\n            setProcessingProgress(data.progress);\n          }\n          break;\n        case 'violation_detected':\n          if (data.violation) {\n            setViolations(prev => [...prev, data.violation]);\n            if (onViolationUpdate) {\n              onViolationUpdate(data.violation);\n            }\n            toast.error(`🚨 Violation: ${data.violation.description || 'Hygiene protocol violation'}`);\n          }\n          break;\n        case 'processing_progress':\n          if (data.progress !== undefined) {\n            setProcessingProgress(data.progress);\n          }\n          if (data.status) {\n            console.log('📊 Processing status:', data.status);\n          }\n          break;\n        case 'processing_started':\n          setIsProcessing(true);\n          setProcessingProgress(0);\n          toast.success('🎬 Video processing started');\n          break;\n        case 'processing_complete':\n          setIsProcessing(false);\n          setProcessingProgress(100);\n          toast.success('🎉 Video processing completed!');\n          break;\n        case 'processing_stopped':\n          setIsProcessing(false);\n          toast.info('⏹️ Video processing stopped');\n          break;\n        case 'error':\n          console.error('❌ WebSocket error message:', data.error);\n          toast.error(`Error: ${data.error || 'Unknown error occurred'}`);\n          if (data.fatal) {\n            setIsProcessing(false);\n          }\n          break;\n        case 'status_update':\n          console.log('📊 Status update:', data.status);\n          if (((_data$status = data.status) === null || _data$status === void 0 ? void 0 : _data$status.frames_processed) !== undefined) {\n            // Calculate progress based on frames processed\n            const totalFrames = data.status.total_frames || 1;\n            const processed = data.status.frames_processed || 0;\n            const progress = Math.min(processed / totalFrames * 100, 100);\n            setProcessingProgress(progress);\n          }\n          break;\n        case 'connection_established':\n          console.log('✅ WebSocket connection established');\n          toast.success('🔌 Connected to real-time feed');\n          break;\n        case 'heartbeat':\n          // Silent heartbeat - just log for debugging\n          console.log('💓 WebSocket heartbeat');\n          break;\n        default:\n          console.log('📨 Unknown WebSocket message type:', data.type);\n          break;\n      }\n    } catch (error) {\n      console.error('❌ Error parsing WebSocket message:', error);\n      console.error('Raw message:', event.data);\n    }\n  }, [setCurrentFrame, setDetections, setViolations, setIsProcessing, setProcessingProgress, onDetectionUpdate, onViolationUpdate]);\n\n  // Connect to WebSocket\n  const connectWebSocket = useCallback((url, sessionId) => {\n    try {\n      console.log('🔌 Connecting to WebSocket:', url);\n\n      // Close existing connection if any\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n      const ws = new WebSocket(url);\n      wsRef.current = ws;\n      ws.onopen = event => {\n        console.log('✅ WebSocket connected');\n        toast.success('🔌 Connected to real-time feed');\n\n        // Send initial message if needed\n        if (sessionId) {\n          ws.send(JSON.stringify({\n            type: 'subscribe',\n            session_id: sessionId\n          }));\n        }\n      };\n      ws.onmessage = handleWebSocketMessage;\n      ws.onerror = error => {\n        console.error('❌ WebSocket error:', error);\n        toast.error('WebSocket connection error');\n      };\n      ws.onclose = event => {\n        console.log('🔌 WebSocket closed:', event.code, event.reason);\n        if (event.code === 1000) {\n          // Normal closure\n          console.log('WebSocket closed normally');\n        } else if (event.code === 1006) {\n          // Abnormal closure\n          console.warn('WebSocket closed abnormally');\n          toast.warning('Connection lost - attempting to reconnect...');\n\n          // Attempt to reconnect after a delay\n          setTimeout(() => {\n            var _wsRef$current;\n            if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.CLOSED) {\n              console.log('🔄 Attempting to reconnect...');\n              connectWebSocket(url, sessionId);\n            }\n          }, 3000);\n        } else {\n          toast.warning(`WebSocket connection lost (${event.code})`);\n        }\n      };\n      return ws;\n    } catch (error) {\n      console.error('❌ Failed to create WebSocket connection:', error);\n      toast.error('Failed to establish real-time connection');\n      return null;\n    }\n  }, [wsRef, handleWebSocketMessage]);\n\n  // Disconnect WebSocket\n  const disconnectWebSocket = useCallback(() => {\n    if (wsRef.current) {\n      console.log('🔌 Disconnecting WebSocket');\n      wsRef.current.close(1000, 'User disconnected');\n      wsRef.current = null;\n    }\n  }, [wsRef]);\n\n  // Send message through WebSocket\n  const sendWebSocketMessage = useCallback(message => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      try {\n        const messageStr = typeof message === 'string' ? message : JSON.stringify(message);\n        wsRef.current.send(messageStr);\n        console.log('📤 WebSocket message sent:', message);\n        return true;\n      } catch (error) {\n        console.error('❌ Error sending WebSocket message:', error);\n        return false;\n      }\n    } else {\n      console.warn('⚠️ WebSocket not connected, cannot send message');\n      return false;\n    }\n  }, [wsRef]);\n\n  // Get WebSocket connection status\n  const getConnectionStatus = useCallback(() => {\n    if (!wsRef.current) return 'disconnected';\n    switch (wsRef.current.readyState) {\n      case WebSocket.CONNECTING:\n        return 'connecting';\n      case WebSocket.OPEN:\n        return 'connected';\n      case WebSocket.CLOSING:\n        return 'closing';\n      case WebSocket.CLOSED:\n        return 'disconnected';\n      default:\n        return 'unknown';\n    }\n  }, [wsRef]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      disconnectWebSocket();\n    };\n  }, [disconnectWebSocket]);\n  return {\n    connectWebSocket,\n    disconnectWebSocket,\n    sendWebSocketMessage,\n    getConnectionStatus\n  };\n};\n_s(useWebSocket, \"LPYUokczuhdGMwsDZBFAa9cBo9M=\");\nexport default useWebSocket;","map":{"version":3,"names":["useCallback","useEffect","toast","useWebSocket","wsRef","setCurrentFrame","setDetections","setViolations","setIsProcessing","setProcessingProgress","onDetectionUpdate","onViolationUpdate","_s","handleWebSocketMessage","event","_data$frame_data","_data$detections","_data$status","data","JSON","parse","console","log","type","hasFrameData","frame_data","frameDataLength","length","hasDetections","detections","detectionsCount","progress","allKeys","Object","keys","undefined","violation","prev","error","description","status","success","info","fatal","frames_processed","totalFrames","total_frames","processed","Math","min","connectWebSocket","url","sessionId","current","close","ws","WebSocket","onopen","send","stringify","session_id","onmessage","onerror","onclose","code","reason","warn","warning","setTimeout","_wsRef$current","readyState","CLOSED","disconnectWebSocket","sendWebSocketMessage","message","OPEN","messageStr","getConnectionStatus","CONNECTING","CLOSING"],"sources":["C:/Users/ayoub/OneDrive/Desktop/eagleAI/pizza_store_detection/services/frontend/src/components/VideoProcessor/hooks/useWebSocket.js"],"sourcesContent":["/**\n * useWebSocket - Custom hook for WebSocket connection management\n */\n\nimport { useCallback, useEffect } from 'react';\nimport { toast } from 'react-toastify';\n\nconst useWebSocket = ({\n  wsRef,\n  setCurrentFrame,\n  setDetections,\n  setViolations,\n  setIsProcessing,\n  setProcessingProgress,\n  onDetectionUpdate,\n  onViolationUpdate\n}) => {\n  // Handle incoming WebSocket messages\n  const handleWebSocketMessage = useCallback((event) => {\n    try {\n      const data = JSON.parse(event.data);\n      console.log('📨 WebSocket message received:', data.type);\n\n      switch (data.type) {\n        case 'frame_update':\n        case 'frame_processed':\n          console.log('🖼️ Frame message received:', {\n            type: data.type,\n            hasFrameData: !!data.frame_data,\n            frameDataLength: data.frame_data?.length || 0,\n            hasDetections: !!data.detections,\n            detectionsCount: data.detections?.length || 0,\n            progress: data.progress,\n            allKeys: Object.keys(data)\n          });\n\n          // Update current frame\n          if (data.frame_data) {\n            setCurrentFrame(data.frame_data);\n            console.log('✅ Frame data updated - length:', data.frame_data.length);\n          } else {\n            console.log('❌ No frame_data in message');\n          }\n\n          // Update detections\n          if (data.detections) {\n            setDetections(data.detections);\n            if (onDetectionUpdate) {\n              onDetectionUpdate(data.detections);\n            }\n          }\n\n          // Update processing progress if available\n          if (data.progress !== undefined) {\n            setProcessingProgress(data.progress);\n          }\n          break;\n\n        case 'violation_detected':\n          if (data.violation) {\n            setViolations(prev => [...prev, data.violation]);\n            if (onViolationUpdate) {\n              onViolationUpdate(data.violation);\n            }\n            toast.error(`🚨 Violation: ${data.violation.description || 'Hygiene protocol violation'}`);\n          }\n          break;\n\n        case 'processing_progress':\n          if (data.progress !== undefined) {\n            setProcessingProgress(data.progress);\n          }\n          if (data.status) {\n            console.log('📊 Processing status:', data.status);\n          }\n          break;\n\n        case 'processing_started':\n          setIsProcessing(true);\n          setProcessingProgress(0);\n          toast.success('🎬 Video processing started');\n          break;\n\n        case 'processing_complete':\n          setIsProcessing(false);\n          setProcessingProgress(100);\n          toast.success('🎉 Video processing completed!');\n          break;\n\n        case 'processing_stopped':\n          setIsProcessing(false);\n          toast.info('⏹️ Video processing stopped');\n          break;\n\n        case 'error':\n          console.error('❌ WebSocket error message:', data.error);\n          toast.error(`Error: ${data.error || 'Unknown error occurred'}`);\n          if (data.fatal) {\n            setIsProcessing(false);\n          }\n          break;\n\n        case 'status_update':\n          console.log('📊 Status update:', data.status);\n          if (data.status?.frames_processed !== undefined) {\n            // Calculate progress based on frames processed\n            const totalFrames = data.status.total_frames || 1;\n            const processed = data.status.frames_processed || 0;\n            const progress = Math.min((processed / totalFrames) * 100, 100);\n            setProcessingProgress(progress);\n          }\n          break;\n\n        case 'connection_established':\n          console.log('✅ WebSocket connection established');\n          toast.success('🔌 Connected to real-time feed');\n          break;\n\n        case 'heartbeat':\n          // Silent heartbeat - just log for debugging\n          console.log('💓 WebSocket heartbeat');\n          break;\n\n        default:\n          console.log('📨 Unknown WebSocket message type:', data.type);\n          break;\n      }\n    } catch (error) {\n      console.error('❌ Error parsing WebSocket message:', error);\n      console.error('Raw message:', event.data);\n    }\n  }, [\n    setCurrentFrame,\n    setDetections,\n    setViolations,\n    setIsProcessing,\n    setProcessingProgress,\n    onDetectionUpdate,\n    onViolationUpdate\n  ]);\n\n  // Connect to WebSocket\n  const connectWebSocket = useCallback((url, sessionId) => {\n    try {\n      console.log('🔌 Connecting to WebSocket:', url);\n      \n      // Close existing connection if any\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n\n      const ws = new WebSocket(url);\n      wsRef.current = ws;\n\n      ws.onopen = (event) => {\n        console.log('✅ WebSocket connected');\n        toast.success('🔌 Connected to real-time feed');\n        \n        // Send initial message if needed\n        if (sessionId) {\n          ws.send(JSON.stringify({\n            type: 'subscribe',\n            session_id: sessionId\n          }));\n        }\n      };\n\n      ws.onmessage = handleWebSocketMessage;\n\n      ws.onerror = (error) => {\n        console.error('❌ WebSocket error:', error);\n        toast.error('WebSocket connection error');\n      };\n\n      ws.onclose = (event) => {\n        console.log('🔌 WebSocket closed:', event.code, event.reason);\n        \n        if (event.code === 1000) {\n          // Normal closure\n          console.log('WebSocket closed normally');\n        } else if (event.code === 1006) {\n          // Abnormal closure\n          console.warn('WebSocket closed abnormally');\n          toast.warning('Connection lost - attempting to reconnect...');\n          \n          // Attempt to reconnect after a delay\n          setTimeout(() => {\n            if (wsRef.current?.readyState === WebSocket.CLOSED) {\n              console.log('🔄 Attempting to reconnect...');\n              connectWebSocket(url, sessionId);\n            }\n          }, 3000);\n        } else {\n          toast.warning(`WebSocket connection lost (${event.code})`);\n        }\n      };\n\n      return ws;\n    } catch (error) {\n      console.error('❌ Failed to create WebSocket connection:', error);\n      toast.error('Failed to establish real-time connection');\n      return null;\n    }\n  }, [wsRef, handleWebSocketMessage]);\n\n  // Disconnect WebSocket\n  const disconnectWebSocket = useCallback(() => {\n    if (wsRef.current) {\n      console.log('🔌 Disconnecting WebSocket');\n      wsRef.current.close(1000, 'User disconnected');\n      wsRef.current = null;\n    }\n  }, [wsRef]);\n\n  // Send message through WebSocket\n  const sendWebSocketMessage = useCallback((message) => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n      try {\n        const messageStr = typeof message === 'string' ? message : JSON.stringify(message);\n        wsRef.current.send(messageStr);\n        console.log('📤 WebSocket message sent:', message);\n        return true;\n      } catch (error) {\n        console.error('❌ Error sending WebSocket message:', error);\n        return false;\n      }\n    } else {\n      console.warn('⚠️ WebSocket not connected, cannot send message');\n      return false;\n    }\n  }, [wsRef]);\n\n  // Get WebSocket connection status\n  const getConnectionStatus = useCallback(() => {\n    if (!wsRef.current) return 'disconnected';\n    \n    switch (wsRef.current.readyState) {\n      case WebSocket.CONNECTING:\n        return 'connecting';\n      case WebSocket.OPEN:\n        return 'connected';\n      case WebSocket.CLOSING:\n        return 'closing';\n      case WebSocket.CLOSED:\n        return 'disconnected';\n      default:\n        return 'unknown';\n    }\n  }, [wsRef]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      disconnectWebSocket();\n    };\n  }, [disconnectWebSocket]);\n\n  return {\n    connectWebSocket,\n    disconnectWebSocket,\n    sendWebSocketMessage,\n    getConnectionStatus\n  };\n};\n\nexport default useWebSocket;\n"],"mappings":";AAAA;AACA;AACA;;AAEA,SAASA,WAAW,EAAEC,SAAS,QAAQ,OAAO;AAC9C,SAASC,KAAK,QAAQ,gBAAgB;AAEtC,MAAMC,YAAY,GAAGA,CAAC;EACpBC,KAAK;EACLC,eAAe;EACfC,aAAa;EACbC,aAAa;EACbC,eAAe;EACfC,qBAAqB;EACrBC,iBAAiB;EACjBC;AACF,CAAC,KAAK;EAAAC,EAAA;EACJ;EACA,MAAMC,sBAAsB,GAAGb,WAAW,CAAEc,KAAK,IAAK;IAAA,IAAAC,gBAAA,EAAAC,gBAAA,EAAAC,YAAA;IACpD,IAAI;MACF,MAAMC,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACN,KAAK,CAACI,IAAI,CAAC;MACnCG,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEJ,IAAI,CAACK,IAAI,CAAC;MAExD,QAAQL,IAAI,CAACK,IAAI;QACf,KAAK,cAAc;QACnB,KAAK,iBAAiB;UACpBF,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAE;YACzCC,IAAI,EAAEL,IAAI,CAACK,IAAI;YACfC,YAAY,EAAE,CAAC,CAACN,IAAI,CAACO,UAAU;YAC/BC,eAAe,EAAE,EAAAX,gBAAA,GAAAG,IAAI,CAACO,UAAU,cAAAV,gBAAA,uBAAfA,gBAAA,CAAiBY,MAAM,KAAI,CAAC;YAC7CC,aAAa,EAAE,CAAC,CAACV,IAAI,CAACW,UAAU;YAChCC,eAAe,EAAE,EAAAd,gBAAA,GAAAE,IAAI,CAACW,UAAU,cAAAb,gBAAA,uBAAfA,gBAAA,CAAiBW,MAAM,KAAI,CAAC;YAC7CI,QAAQ,EAAEb,IAAI,CAACa,QAAQ;YACvBC,OAAO,EAAEC,MAAM,CAACC,IAAI,CAAChB,IAAI;UAC3B,CAAC,CAAC;;UAEF;UACA,IAAIA,IAAI,CAACO,UAAU,EAAE;YACnBpB,eAAe,CAACa,IAAI,CAACO,UAAU,CAAC;YAChCJ,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEJ,IAAI,CAACO,UAAU,CAACE,MAAM,CAAC;UACvE,CAAC,MAAM;YACLN,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;UAC3C;;UAEA;UACA,IAAIJ,IAAI,CAACW,UAAU,EAAE;YACnBvB,aAAa,CAACY,IAAI,CAACW,UAAU,CAAC;YAC9B,IAAInB,iBAAiB,EAAE;cACrBA,iBAAiB,CAACQ,IAAI,CAACW,UAAU,CAAC;YACpC;UACF;;UAEA;UACA,IAAIX,IAAI,CAACa,QAAQ,KAAKI,SAAS,EAAE;YAC/B1B,qBAAqB,CAACS,IAAI,CAACa,QAAQ,CAAC;UACtC;UACA;QAEF,KAAK,oBAAoB;UACvB,IAAIb,IAAI,CAACkB,SAAS,EAAE;YAClB7B,aAAa,CAAC8B,IAAI,IAAI,CAAC,GAAGA,IAAI,EAAEnB,IAAI,CAACkB,SAAS,CAAC,CAAC;YAChD,IAAIzB,iBAAiB,EAAE;cACrBA,iBAAiB,CAACO,IAAI,CAACkB,SAAS,CAAC;YACnC;YACAlC,KAAK,CAACoC,KAAK,CAAC,iBAAiBpB,IAAI,CAACkB,SAAS,CAACG,WAAW,IAAI,4BAA4B,EAAE,CAAC;UAC5F;UACA;QAEF,KAAK,qBAAqB;UACxB,IAAIrB,IAAI,CAACa,QAAQ,KAAKI,SAAS,EAAE;YAC/B1B,qBAAqB,CAACS,IAAI,CAACa,QAAQ,CAAC;UACtC;UACA,IAAIb,IAAI,CAACsB,MAAM,EAAE;YACfnB,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEJ,IAAI,CAACsB,MAAM,CAAC;UACnD;UACA;QAEF,KAAK,oBAAoB;UACvBhC,eAAe,CAAC,IAAI,CAAC;UACrBC,qBAAqB,CAAC,CAAC,CAAC;UACxBP,KAAK,CAACuC,OAAO,CAAC,6BAA6B,CAAC;UAC5C;QAEF,KAAK,qBAAqB;UACxBjC,eAAe,CAAC,KAAK,CAAC;UACtBC,qBAAqB,CAAC,GAAG,CAAC;UAC1BP,KAAK,CAACuC,OAAO,CAAC,gCAAgC,CAAC;UAC/C;QAEF,KAAK,oBAAoB;UACvBjC,eAAe,CAAC,KAAK,CAAC;UACtBN,KAAK,CAACwC,IAAI,CAAC,6BAA6B,CAAC;UACzC;QAEF,KAAK,OAAO;UACVrB,OAAO,CAACiB,KAAK,CAAC,4BAA4B,EAAEpB,IAAI,CAACoB,KAAK,CAAC;UACvDpC,KAAK,CAACoC,KAAK,CAAC,UAAUpB,IAAI,CAACoB,KAAK,IAAI,wBAAwB,EAAE,CAAC;UAC/D,IAAIpB,IAAI,CAACyB,KAAK,EAAE;YACdnC,eAAe,CAAC,KAAK,CAAC;UACxB;UACA;QAEF,KAAK,eAAe;UAClBa,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAEJ,IAAI,CAACsB,MAAM,CAAC;UAC7C,IAAI,EAAAvB,YAAA,GAAAC,IAAI,CAACsB,MAAM,cAAAvB,YAAA,uBAAXA,YAAA,CAAa2B,gBAAgB,MAAKT,SAAS,EAAE;YAC/C;YACA,MAAMU,WAAW,GAAG3B,IAAI,CAACsB,MAAM,CAACM,YAAY,IAAI,CAAC;YACjD,MAAMC,SAAS,GAAG7B,IAAI,CAACsB,MAAM,CAACI,gBAAgB,IAAI,CAAC;YACnD,MAAMb,QAAQ,GAAGiB,IAAI,CAACC,GAAG,CAAEF,SAAS,GAAGF,WAAW,GAAI,GAAG,EAAE,GAAG,CAAC;YAC/DpC,qBAAqB,CAACsB,QAAQ,CAAC;UACjC;UACA;QAEF,KAAK,wBAAwB;UAC3BV,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;UACjDpB,KAAK,CAACuC,OAAO,CAAC,gCAAgC,CAAC;UAC/C;QAEF,KAAK,WAAW;UACd;UACApB,OAAO,CAACC,GAAG,CAAC,wBAAwB,CAAC;UACrC;QAEF;UACED,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAEJ,IAAI,CAACK,IAAI,CAAC;UAC5D;MACJ;IACF,CAAC,CAAC,OAAOe,KAAK,EAAE;MACdjB,OAAO,CAACiB,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;MAC1DjB,OAAO,CAACiB,KAAK,CAAC,cAAc,EAAExB,KAAK,CAACI,IAAI,CAAC;IAC3C;EACF,CAAC,EAAE,CACDb,eAAe,EACfC,aAAa,EACbC,aAAa,EACbC,eAAe,EACfC,qBAAqB,EACrBC,iBAAiB,EACjBC,iBAAiB,CAClB,CAAC;;EAEF;EACA,MAAMuC,gBAAgB,GAAGlD,WAAW,CAAC,CAACmD,GAAG,EAAEC,SAAS,KAAK;IACvD,IAAI;MACF/B,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAE6B,GAAG,CAAC;;MAE/C;MACA,IAAI/C,KAAK,CAACiD,OAAO,EAAE;QACjBjD,KAAK,CAACiD,OAAO,CAACC,KAAK,CAAC,CAAC;MACvB;MAEA,MAAMC,EAAE,GAAG,IAAIC,SAAS,CAACL,GAAG,CAAC;MAC7B/C,KAAK,CAACiD,OAAO,GAAGE,EAAE;MAElBA,EAAE,CAACE,MAAM,GAAI3C,KAAK,IAAK;QACrBO,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;QACpCpB,KAAK,CAACuC,OAAO,CAAC,gCAAgC,CAAC;;QAE/C;QACA,IAAIW,SAAS,EAAE;UACbG,EAAE,CAACG,IAAI,CAACvC,IAAI,CAACwC,SAAS,CAAC;YACrBpC,IAAI,EAAE,WAAW;YACjBqC,UAAU,EAAER;UACd,CAAC,CAAC,CAAC;QACL;MACF,CAAC;MAEDG,EAAE,CAACM,SAAS,GAAGhD,sBAAsB;MAErC0C,EAAE,CAACO,OAAO,GAAIxB,KAAK,IAAK;QACtBjB,OAAO,CAACiB,KAAK,CAAC,oBAAoB,EAAEA,KAAK,CAAC;QAC1CpC,KAAK,CAACoC,KAAK,CAAC,4BAA4B,CAAC;MAC3C,CAAC;MAEDiB,EAAE,CAACQ,OAAO,GAAIjD,KAAK,IAAK;QACtBO,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAER,KAAK,CAACkD,IAAI,EAAElD,KAAK,CAACmD,MAAM,CAAC;QAE7D,IAAInD,KAAK,CAACkD,IAAI,KAAK,IAAI,EAAE;UACvB;UACA3C,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;QAC1C,CAAC,MAAM,IAAIR,KAAK,CAACkD,IAAI,KAAK,IAAI,EAAE;UAC9B;UACA3C,OAAO,CAAC6C,IAAI,CAAC,6BAA6B,CAAC;UAC3ChE,KAAK,CAACiE,OAAO,CAAC,8CAA8C,CAAC;;UAE7D;UACAC,UAAU,CAAC,MAAM;YAAA,IAAAC,cAAA;YACf,IAAI,EAAAA,cAAA,GAAAjE,KAAK,CAACiD,OAAO,cAAAgB,cAAA,uBAAbA,cAAA,CAAeC,UAAU,MAAKd,SAAS,CAACe,MAAM,EAAE;cAClDlD,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;cAC5C4B,gBAAgB,CAACC,GAAG,EAAEC,SAAS,CAAC;YAClC;UACF,CAAC,EAAE,IAAI,CAAC;QACV,CAAC,MAAM;UACLlD,KAAK,CAACiE,OAAO,CAAC,8BAA8BrD,KAAK,CAACkD,IAAI,GAAG,CAAC;QAC5D;MACF,CAAC;MAED,OAAOT,EAAE;IACX,CAAC,CAAC,OAAOjB,KAAK,EAAE;MACdjB,OAAO,CAACiB,KAAK,CAAC,0CAA0C,EAAEA,KAAK,CAAC;MAChEpC,KAAK,CAACoC,KAAK,CAAC,0CAA0C,CAAC;MACvD,OAAO,IAAI;IACb;EACF,CAAC,EAAE,CAAClC,KAAK,EAAES,sBAAsB,CAAC,CAAC;;EAEnC;EACA,MAAM2D,mBAAmB,GAAGxE,WAAW,CAAC,MAAM;IAC5C,IAAII,KAAK,CAACiD,OAAO,EAAE;MACjBhC,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;MACzClB,KAAK,CAACiD,OAAO,CAACC,KAAK,CAAC,IAAI,EAAE,mBAAmB,CAAC;MAC9ClD,KAAK,CAACiD,OAAO,GAAG,IAAI;IACtB;EACF,CAAC,EAAE,CAACjD,KAAK,CAAC,CAAC;;EAEX;EACA,MAAMqE,oBAAoB,GAAGzE,WAAW,CAAE0E,OAAO,IAAK;IACpD,IAAItE,KAAK,CAACiD,OAAO,IAAIjD,KAAK,CAACiD,OAAO,CAACiB,UAAU,KAAKd,SAAS,CAACmB,IAAI,EAAE;MAChE,IAAI;QACF,MAAMC,UAAU,GAAG,OAAOF,OAAO,KAAK,QAAQ,GAAGA,OAAO,GAAGvD,IAAI,CAACwC,SAAS,CAACe,OAAO,CAAC;QAClFtE,KAAK,CAACiD,OAAO,CAACK,IAAI,CAACkB,UAAU,CAAC;QAC9BvD,OAAO,CAACC,GAAG,CAAC,4BAA4B,EAAEoD,OAAO,CAAC;QAClD,OAAO,IAAI;MACb,CAAC,CAAC,OAAOpC,KAAK,EAAE;QACdjB,OAAO,CAACiB,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;QAC1D,OAAO,KAAK;MACd;IACF,CAAC,MAAM;MACLjB,OAAO,CAAC6C,IAAI,CAAC,iDAAiD,CAAC;MAC/D,OAAO,KAAK;IACd;EACF,CAAC,EAAE,CAAC9D,KAAK,CAAC,CAAC;;EAEX;EACA,MAAMyE,mBAAmB,GAAG7E,WAAW,CAAC,MAAM;IAC5C,IAAI,CAACI,KAAK,CAACiD,OAAO,EAAE,OAAO,cAAc;IAEzC,QAAQjD,KAAK,CAACiD,OAAO,CAACiB,UAAU;MAC9B,KAAKd,SAAS,CAACsB,UAAU;QACvB,OAAO,YAAY;MACrB,KAAKtB,SAAS,CAACmB,IAAI;QACjB,OAAO,WAAW;MACpB,KAAKnB,SAAS,CAACuB,OAAO;QACpB,OAAO,SAAS;MAClB,KAAKvB,SAAS,CAACe,MAAM;QACnB,OAAO,cAAc;MACvB;QACE,OAAO,SAAS;IACpB;EACF,CAAC,EAAE,CAACnE,KAAK,CAAC,CAAC;;EAEX;EACAH,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACXuE,mBAAmB,CAAC,CAAC;IACvB,CAAC;EACH,CAAC,EAAE,CAACA,mBAAmB,CAAC,CAAC;EAEzB,OAAO;IACLtB,gBAAgB;IAChBsB,mBAAmB;IACnBC,oBAAoB;IACpBI;EACF,CAAC;AACH,CAAC;AAACjE,EAAA,CAhQIT,YAAY;AAkQlB,eAAeA,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}