{"ast":null,"code":"var _s = $RefreshSig$();\n/**\n * useDetectionDrawing - Custom hook for drawing detection overlays on canvas\n */\n\nimport { useCallback } from 'react';\nconst useDetectionDrawing = ({\n  videoRef,\n  canvasRef,\n  fullScreenCanvasRef\n}) => {\n  _s();\n  // Draw detection bounding boxes and labels\n  const drawDetections = useCallback((detections, options = {}) => {\n    const {\n      canvas = canvasRef.current,\n      video = videoRef.current,\n      showLabels = true,\n      showConfidence = true,\n      lineWidth = 2,\n      fontSize = 12,\n      colors = {\n        person: '#00FF88',\n        hand: '#FFD23F',\n        spoon: '#4a90e2',\n        utensil: '#4a90e2',\n        default: '#4a90e2'\n      }\n    } = options;\n    if (!canvas || !video || !(detections !== null && detections !== void 0 && detections.length)) {\n      // Clear canvas if no detections\n      if (canvas) {\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n      }\n      return;\n    }\n    const ctx = canvas.getContext('2d');\n    const rect = video.getBoundingClientRect();\n\n    // Set canvas size to match video display\n    canvas.width = rect.width;\n    canvas.height = rect.height;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Calculate scale factors\n    const scaleX = rect.width / (video.naturalWidth || rect.width);\n    const scaleY = rect.height / (video.naturalHeight || rect.height);\n    console.log('ðŸŽ¨ Drawing detections:', {\n      count: detections.length,\n      canvasSize: `${canvas.width}x${canvas.height}`,\n      videoSize: `${video.naturalWidth}x${video.naturalHeight}`,\n      displaySize: `${rect.width}x${rect.height}`,\n      scale: `${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`\n    });\n    detections.forEach((detection, index) => {\n      try {\n        const bbox = detection.bbox || detection.bounding_box;\n        if (!bbox) {\n          console.warn('âš ï¸ Detection missing bbox:', detection);\n          return;\n        }\n\n        // Calculate scaled coordinates\n        const x = bbox.x1 * scaleX;\n        const y = bbox.y1 * scaleY;\n        const width = (bbox.x2 - bbox.x1) * scaleX;\n        const height = (bbox.y2 - bbox.y1) * scaleY;\n\n        // Get class name and confidence\n        const className = detection.class_name || detection.class || 'unknown';\n        const confidence = detection.confidence || 0;\n\n        // Choose color based on class\n        const color = colors[className.toLowerCase()] || colors.default;\n\n        // Draw bounding box\n        ctx.strokeStyle = color;\n        ctx.lineWidth = lineWidth;\n        ctx.strokeRect(x, y, width, height);\n\n        // Draw semi-transparent fill\n        ctx.fillStyle = `${color}20`;\n        ctx.fillRect(x, y, width, height);\n\n        // Draw label background and text\n        if (showLabels) {\n          const label = showConfidence ? `${className} (${(confidence * 100).toFixed(1)}%)` : className;\n          ctx.font = `bold ${fontSize}px Arial`;\n          const textMetrics = ctx.measureText(label);\n          const textWidth = textMetrics.width;\n          const textHeight = fontSize;\n\n          // Label background\n          const labelY = y > textHeight + 4 ? y - textHeight - 4 : y + height + 4;\n          ctx.fillStyle = color;\n          ctx.fillRect(x, labelY, textWidth + 8, textHeight + 4);\n\n          // Label text\n          ctx.fillStyle = 'white';\n          ctx.fillText(label, x + 4, labelY + textHeight);\n        }\n\n        // Draw center point\n        const centerX = x + width / 2;\n        const centerY = y + height / 2;\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI);\n        ctx.fill();\n      } catch (error) {\n        console.error('âŒ Error drawing detection:', error, detection);\n      }\n    });\n    console.log(`âœ… Drew ${detections.length} detections on canvas`);\n  }, [videoRef, canvasRef]);\n\n  // Draw ROI zones\n  const drawROIZones = useCallback((zones, options = {}) => {\n    const {\n      canvas = canvasRef.current,\n      video = videoRef.current,\n      showLabels = true,\n      lineWidth = 2,\n      fontSize = 14,\n      activeColor = '#00FF88',\n      inactiveColor = '#666',\n      requiresScooperColor = '#FFD23F'\n    } = options;\n    if (!canvas || !video || !(zones !== null && zones !== void 0 && zones.length)) return;\n    const ctx = canvas.getContext('2d');\n    const rect = video.getBoundingClientRect();\n\n    // Calculate scale factors (zones are in percentage, need to convert to pixels)\n    const scaleX = rect.width / 100;\n    const scaleY = rect.height / 100;\n    zones.forEach((zone, index) => {\n      try {\n        // Calculate pixel coordinates from percentages\n        const x = zone.x * scaleX;\n        const y = zone.y * scaleY;\n        const width = zone.width * scaleX;\n        const height = zone.height * scaleY;\n\n        // Choose color based on zone properties\n        let color = zone.requires_scooper ? requiresScooperColor : activeColor;\n        if (zone.disabled) color = inactiveColor;\n\n        // Draw zone rectangle\n        ctx.strokeStyle = color;\n        ctx.lineWidth = lineWidth;\n        ctx.setLineDash([5, 5]); // Dashed line for zones\n        ctx.strokeRect(x, y, width, height);\n\n        // Draw semi-transparent fill\n        ctx.fillStyle = `${color}15`;\n        ctx.fillRect(x, y, width, height);\n\n        // Reset line dash\n        ctx.setLineDash([]);\n\n        // Draw zone label\n        if (showLabels) {\n          const label = zone.name || `Zone ${index + 1}`;\n          const subLabel = zone.ingredient_type || '';\n          ctx.font = `bold ${fontSize}px Arial`;\n          const textMetrics = ctx.measureText(label);\n          const textWidth = Math.max(textMetrics.width, ctx.measureText(subLabel).width);\n\n          // Label background\n          ctx.fillStyle = `${color}CC`;\n          ctx.fillRect(x + 4, y + 4, textWidth + 8, fontSize * 2 + 8);\n\n          // Label text\n          ctx.fillStyle = 'white';\n          ctx.fillText(label, x + 8, y + fontSize + 4);\n          if (subLabel) {\n            ctx.font = `${fontSize - 2}px Arial`;\n            ctx.fillText(subLabel, x + 8, y + fontSize * 2 + 2);\n          }\n\n          // Scooper requirement indicator\n          if (zone.requires_scooper) {\n            ctx.fillStyle = requiresScooperColor;\n            ctx.font = `bold ${fontSize - 2}px Arial`;\n            ctx.fillText('ðŸ¥„ Required', x + width - 80, y + fontSize + 4);\n          }\n        }\n      } catch (error) {\n        console.error('âŒ Error drawing ROI zone:', error, zone);\n      }\n    });\n  }, [videoRef, canvasRef]);\n\n  // Draw violation indicators\n  const drawViolations = useCallback((violations, options = {}) => {\n    const {\n      canvas = canvasRef.current,\n      video = videoRef.current,\n      showAlerts = true,\n      pulseAnimation = true,\n      alertColor = '#ef4444',\n      warningColor = '#f59e0b'\n    } = options;\n    if (!canvas || !video || !(violations !== null && violations !== void 0 && violations.length)) return;\n    const ctx = canvas.getContext('2d');\n    const rect = video.getBoundingClientRect();\n    violations.forEach((violation, index) => {\n      try {\n        if (!violation.location_coords) return;\n        const x = violation.location_coords.x * rect.width / 100;\n        const y = violation.location_coords.y * rect.height / 100;\n        const color = violation.severity === 'critical' ? alertColor : warningColor;\n        const radius = pulseAnimation ? 15 + Math.sin(Date.now() / 200) * 5 : 15;\n\n        // Draw violation indicator\n        ctx.fillStyle = `${color}80`;\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 3;\n        ctx.stroke();\n\n        // Draw violation icon\n        ctx.fillStyle = color;\n        ctx.font = 'bold 20px Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText('âš ï¸', x, y + 7);\n\n        // Draw violation label if enabled\n        if (showAlerts) {\n          const label = violation.type || 'Violation';\n          ctx.font = 'bold 12px Arial';\n          ctx.textAlign = 'left';\n          const textWidth = ctx.measureText(label).width;\n\n          // Label background\n          ctx.fillStyle = `${color}CC`;\n          ctx.fillRect(x + 20, y - 10, textWidth + 8, 20);\n\n          // Label text\n          ctx.fillStyle = 'white';\n          ctx.fillText(label, x + 24, y + 4);\n        }\n      } catch (error) {\n        console.error('âŒ Error drawing violation:', error, violation);\n      }\n    });\n\n    // Reset text alignment\n    ctx.textAlign = 'left';\n  }, [videoRef, canvasRef]);\n\n  // Clear canvas\n  const clearCanvas = useCallback((canvas = canvasRef.current) => {\n    if (canvas) {\n      const ctx = canvas.getContext('2d');\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n  }, [canvasRef]);\n\n  // Resize canvas to match video\n  const resizeCanvas = useCallback((canvas = canvasRef.current, video = videoRef.current) => {\n    if (canvas && video) {\n      const rect = video.getBoundingClientRect();\n      canvas.width = rect.width;\n      canvas.height = rect.height;\n      canvas.style.width = `${rect.width}px`;\n      canvas.style.height = `${rect.height}px`;\n    }\n  }, [videoRef, canvasRef]);\n  return {\n    drawDetections,\n    drawROIZones,\n    drawViolations,\n    clearCanvas,\n    resizeCanvas\n  };\n};\n_s(useDetectionDrawing, \"eMl/0g6lh0w8z0RY0fIG0bJEthg=\");\nexport default useDetectionDrawing;","map":{"version":3,"names":["useCallback","useDetectionDrawing","videoRef","canvasRef","fullScreenCanvasRef","_s","drawDetections","detections","options","canvas","current","video","showLabels","showConfidence","lineWidth","fontSize","colors","person","hand","spoon","utensil","default","length","ctx","getContext","clearRect","width","height","rect","getBoundingClientRect","scaleX","naturalWidth","scaleY","naturalHeight","console","log","count","canvasSize","videoSize","displaySize","scale","toFixed","forEach","detection","index","bbox","bounding_box","warn","x","x1","y","y1","x2","y2","className","class_name","class","confidence","color","toLowerCase","strokeStyle","strokeRect","fillStyle","fillRect","label","font","textMetrics","measureText","textWidth","textHeight","labelY","fillText","centerX","centerY","beginPath","arc","Math","PI","fill","error","drawROIZones","zones","activeColor","inactiveColor","requiresScooperColor","zone","requires_scooper","disabled","setLineDash","name","subLabel","ingredient_type","max","drawViolations","violations","showAlerts","pulseAnimation","alertColor","warningColor","violation","location_coords","severity","radius","sin","Date","now","stroke","textAlign","type","clearCanvas","resizeCanvas","style"],"sources":["C:/Users/ayoub/OneDrive/Desktop/eagleAI/pizza_store_detection/services/frontend/src/components/VideoProcessor/hooks/useDetectionDrawing.js"],"sourcesContent":["/**\n * useDetectionDrawing - Custom hook for drawing detection overlays on canvas\n */\n\nimport { useCallback } from 'react';\n\nconst useDetectionDrawing = ({ videoRef, canvasRef, fullScreenCanvasRef }) => {\n  // Draw detection bounding boxes and labels\n  const drawDetections = useCallback((detections, options = {}) => {\n    const {\n      canvas = canvasRef.current,\n      video = videoRef.current,\n      showLabels = true,\n      showConfidence = true,\n      lineWidth = 2,\n      fontSize = 12,\n      colors = {\n        person: '#00FF88',\n        hand: '#FFD23F',\n        spoon: '#4a90e2',\n        utensil: '#4a90e2',\n        default: '#4a90e2'\n      }\n    } = options;\n\n    if (!canvas || !video || !detections?.length) {\n      // Clear canvas if no detections\n      if (canvas) {\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n      }\n      return;\n    }\n\n    const ctx = canvas.getContext('2d');\n    const rect = video.getBoundingClientRect();\n\n    // Set canvas size to match video display\n    canvas.width = rect.width;\n    canvas.height = rect.height;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Calculate scale factors\n    const scaleX = rect.width / (video.naturalWidth || rect.width);\n    const scaleY = rect.height / (video.naturalHeight || rect.height);\n\n    console.log('ðŸŽ¨ Drawing detections:', {\n      count: detections.length,\n      canvasSize: `${canvas.width}x${canvas.height}`,\n      videoSize: `${video.naturalWidth}x${video.naturalHeight}`,\n      displaySize: `${rect.width}x${rect.height}`,\n      scale: `${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`\n    });\n\n    detections.forEach((detection, index) => {\n      try {\n        const bbox = detection.bbox || detection.bounding_box;\n        if (!bbox) {\n          console.warn('âš ï¸ Detection missing bbox:', detection);\n          return;\n        }\n\n        // Calculate scaled coordinates\n        const x = bbox.x1 * scaleX;\n        const y = bbox.y1 * scaleY;\n        const width = (bbox.x2 - bbox.x1) * scaleX;\n        const height = (bbox.y2 - bbox.y1) * scaleY;\n\n        // Get class name and confidence\n        const className = detection.class_name || detection.class || 'unknown';\n        const confidence = detection.confidence || 0;\n\n        // Choose color based on class\n        const color = colors[className.toLowerCase()] || colors.default;\n\n        // Draw bounding box\n        ctx.strokeStyle = color;\n        ctx.lineWidth = lineWidth;\n        ctx.strokeRect(x, y, width, height);\n\n        // Draw semi-transparent fill\n        ctx.fillStyle = `${color}20`;\n        ctx.fillRect(x, y, width, height);\n\n        // Draw label background and text\n        if (showLabels) {\n          const label = showConfidence \n            ? `${className} (${(confidence * 100).toFixed(1)}%)`\n            : className;\n\n          ctx.font = `bold ${fontSize}px Arial`;\n          const textMetrics = ctx.measureText(label);\n          const textWidth = textMetrics.width;\n          const textHeight = fontSize;\n\n          // Label background\n          const labelY = y > textHeight + 4 ? y - textHeight - 4 : y + height + 4;\n          ctx.fillStyle = color;\n          ctx.fillRect(x, labelY, textWidth + 8, textHeight + 4);\n\n          // Label text\n          ctx.fillStyle = 'white';\n          ctx.fillText(label, x + 4, labelY + textHeight);\n        }\n\n        // Draw center point\n        const centerX = x + width / 2;\n        const centerY = y + height / 2;\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI);\n        ctx.fill();\n\n      } catch (error) {\n        console.error('âŒ Error drawing detection:', error, detection);\n      }\n    });\n\n    console.log(`âœ… Drew ${detections.length} detections on canvas`);\n  }, [videoRef, canvasRef]);\n\n  // Draw ROI zones\n  const drawROIZones = useCallback((zones, options = {}) => {\n    const {\n      canvas = canvasRef.current,\n      video = videoRef.current,\n      showLabels = true,\n      lineWidth = 2,\n      fontSize = 14,\n      activeColor = '#00FF88',\n      inactiveColor = '#666',\n      requiresScooperColor = '#FFD23F'\n    } = options;\n\n    if (!canvas || !video || !zones?.length) return;\n\n    const ctx = canvas.getContext('2d');\n    const rect = video.getBoundingClientRect();\n\n    // Calculate scale factors (zones are in percentage, need to convert to pixels)\n    const scaleX = rect.width / 100;\n    const scaleY = rect.height / 100;\n\n    zones.forEach((zone, index) => {\n      try {\n        // Calculate pixel coordinates from percentages\n        const x = zone.x * scaleX;\n        const y = zone.y * scaleY;\n        const width = zone.width * scaleX;\n        const height = zone.height * scaleY;\n\n        // Choose color based on zone properties\n        let color = zone.requires_scooper ? requiresScooperColor : activeColor;\n        if (zone.disabled) color = inactiveColor;\n\n        // Draw zone rectangle\n        ctx.strokeStyle = color;\n        ctx.lineWidth = lineWidth;\n        ctx.setLineDash([5, 5]); // Dashed line for zones\n        ctx.strokeRect(x, y, width, height);\n\n        // Draw semi-transparent fill\n        ctx.fillStyle = `${color}15`;\n        ctx.fillRect(x, y, width, height);\n\n        // Reset line dash\n        ctx.setLineDash([]);\n\n        // Draw zone label\n        if (showLabels) {\n          const label = zone.name || `Zone ${index + 1}`;\n          const subLabel = zone.ingredient_type || '';\n\n          ctx.font = `bold ${fontSize}px Arial`;\n          const textMetrics = ctx.measureText(label);\n          const textWidth = Math.max(textMetrics.width, ctx.measureText(subLabel).width);\n\n          // Label background\n          ctx.fillStyle = `${color}CC`;\n          ctx.fillRect(x + 4, y + 4, textWidth + 8, fontSize * 2 + 8);\n\n          // Label text\n          ctx.fillStyle = 'white';\n          ctx.fillText(label, x + 8, y + fontSize + 4);\n          \n          if (subLabel) {\n            ctx.font = `${fontSize - 2}px Arial`;\n            ctx.fillText(subLabel, x + 8, y + fontSize * 2 + 2);\n          }\n\n          // Scooper requirement indicator\n          if (zone.requires_scooper) {\n            ctx.fillStyle = requiresScooperColor;\n            ctx.font = `bold ${fontSize - 2}px Arial`;\n            ctx.fillText('ðŸ¥„ Required', x + width - 80, y + fontSize + 4);\n          }\n        }\n\n      } catch (error) {\n        console.error('âŒ Error drawing ROI zone:', error, zone);\n      }\n    });\n  }, [videoRef, canvasRef]);\n\n  // Draw violation indicators\n  const drawViolations = useCallback((violations, options = {}) => {\n    const {\n      canvas = canvasRef.current,\n      video = videoRef.current,\n      showAlerts = true,\n      pulseAnimation = true,\n      alertColor = '#ef4444',\n      warningColor = '#f59e0b'\n    } = options;\n\n    if (!canvas || !video || !violations?.length) return;\n\n    const ctx = canvas.getContext('2d');\n    const rect = video.getBoundingClientRect();\n\n    violations.forEach((violation, index) => {\n      try {\n        if (!violation.location_coords) return;\n\n        const x = violation.location_coords.x * rect.width / 100;\n        const y = violation.location_coords.y * rect.height / 100;\n\n        const color = violation.severity === 'critical' ? alertColor : warningColor;\n        const radius = pulseAnimation ? 15 + Math.sin(Date.now() / 200) * 5 : 15;\n\n        // Draw violation indicator\n        ctx.fillStyle = `${color}80`;\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, 2 * Math.PI);\n        ctx.fill();\n\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 3;\n        ctx.stroke();\n\n        // Draw violation icon\n        ctx.fillStyle = color;\n        ctx.font = 'bold 20px Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText('âš ï¸', x, y + 7);\n\n        // Draw violation label if enabled\n        if (showAlerts) {\n          const label = violation.type || 'Violation';\n          ctx.font = 'bold 12px Arial';\n          ctx.textAlign = 'left';\n          const textWidth = ctx.measureText(label).width;\n\n          // Label background\n          ctx.fillStyle = `${color}CC`;\n          ctx.fillRect(x + 20, y - 10, textWidth + 8, 20);\n\n          // Label text\n          ctx.fillStyle = 'white';\n          ctx.fillText(label, x + 24, y + 4);\n        }\n\n      } catch (error) {\n        console.error('âŒ Error drawing violation:', error, violation);\n      }\n    });\n\n    // Reset text alignment\n    ctx.textAlign = 'left';\n  }, [videoRef, canvasRef]);\n\n  // Clear canvas\n  const clearCanvas = useCallback((canvas = canvasRef.current) => {\n    if (canvas) {\n      const ctx = canvas.getContext('2d');\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n  }, [canvasRef]);\n\n  // Resize canvas to match video\n  const resizeCanvas = useCallback((canvas = canvasRef.current, video = videoRef.current) => {\n    if (canvas && video) {\n      const rect = video.getBoundingClientRect();\n      canvas.width = rect.width;\n      canvas.height = rect.height;\n      canvas.style.width = `${rect.width}px`;\n      canvas.style.height = `${rect.height}px`;\n    }\n  }, [videoRef, canvasRef]);\n\n  return {\n    drawDetections,\n    drawROIZones,\n    drawViolations,\n    clearCanvas,\n    resizeCanvas\n  };\n};\n\nexport default useDetectionDrawing;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}